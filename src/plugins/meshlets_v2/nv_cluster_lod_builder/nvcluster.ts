import { clusterize } from "./clusterizer";
import { ClusterStorage } from "./nvcluster_storage";
import { resizeArray, createArrayView } from "./nvclusterlod_common";

export class Range {
    public offset: number = 0;
    public count: number = 0;

    constructor(offset: number = 0, count: number = 0) {
        this.offset = offset;
        this.count = count;
    }
};

export class Config {
    // Minimum number of elements contained in a cluster
    public minClusterSize: number = 1;
    // Maximum number of elements contained in a cluster
    public maxClusterSize: number = ~0;
    // Cost penalty for under-filling clusters
    public costUnderfill: number = 1.0;
    // Cost penalty for overlapping bounding boxes
    public costOverlap: number = 0.01;
    // If nonzero the set of input elements will first be split along its median
    // until each subset contains at most preSplitThreshold elements prior to actual
    // clustering. This is an optimization intended to speed up clustering of large
    // sets of elements
    public preSplitThreshold: number = 0;
};

export class AABB {
    public bboxMin: number[] = [Infinity, Infinity, Infinity];
    public bboxMax: number[] = [-Infinity, -Infinity, -Infinity];

    constructor(bboxMin: number[] = [Infinity, Infinity, Infinity], bboxMax: number[] = [-Infinity, -Infinity, -Infinity]) {
        this.bboxMin = bboxMin;
        this.bboxMax = bboxMax;
    }
};

// Spatial definition of elements to cluster
export class SpatialElements {
    // Bounding boxes of elements to cluster
    public boundingBoxes: AABB[];

    // Center positions (xyz) of elements to cluster
    public centroids: number[];

    // Number of elements
    public elementCount: number = 0;
};

// Definition of the connectivity of the items to cluster
// While the data structure defines unidirectional connections the underlying
// clustering requires all connections to be explicitly bidirectional (if node A has a connection to node B, then node B has
// a connection to node A)
export class Graph {
    // Each node is defined by its connections to other nodes, stored at node.offset in connectionTargets. Each node has node.count connections
    public nodes: Range[];
    // Total number of nodes in the graph
    public nodeCount: number = 0;


    // Connection targets for the nodes, referenced by nodes
    public connectionTargets: number[];
    // Weight of each connection
    public connectionWeights: number[];
    // Total number of connections in the graph
    public connectionCount: number = 0;
};

// Definition of the input data
export class Input {
    // Clustering configuration
    public config: Config = new Config();
    // Set of elements to cluster, required
    public spatialElements: SpatialElements = new SpatialElements();
    // Optional graph defining the weighted connectivity between elements, used to optimize a cost function
    // when clustering
    public graph: Graph;
};

// Structure to request the memory requirements to individually cluster the provided segments of the input data
export class ClusterGetRequirementsSegmentedInfo {
    // Input elements to cluster
    public input: Input;
    // Each segment is defined by a range within the array of elements defined in input
    public elementSegments: Range[];
    // Number of segments
    public elementSegmentCount: number = 0;
};

// Structure to request the memory requirements to cluster the input data
export class ClusterGetRequirementsInfo {
    // Input elements to cluster
    public input: Input;
};

// Structure to request individual clustering of the provided segments of the input data
export class ClusterCreateSegmentedInfo {
    public input: Input;

    // Each segment is defined by a range within the array of elements defined in input
    public elementSegments: Range[];
    // Number of segments
    public elementSegmentCount: number = 0;
};

// Output of the clustering where the clusterRanges define a partition of the input elements
export class Output {
    // Clusters defined by ranges of element indices, where each cluster starts at range.offset in clusteredElementIndices and contains range.count elements
    public clusterRanges: Range[];
    // Indices of the elements, referenced by clusterRanges
    public clusteredElementIndices: number[];
    // Total number of clusters generated by the clustering (may be less than maxClusterCount)
    public clusterCount: number = 0;
    // Total number of cluster element indices (FIXME why, shouldn't this be the same as the input?)
    public clusteredElementIndexCount: number = 0;
};

// Memory requirements for clustering
export class Requirements {
    // Maximum number of generated clusters
    public maxClusterCount: number = 0;
    // Maximum total number of elements referenced by the clusters
    public maxClusteredElementCount: number = 0;
};

// Structure to request clustering the input set of elements
export class ClusterCreateInfo {
    // Input elements to cluster
    public input: Input;
};

export enum Result {
    SUCCESS,
    ERROR_INVALID_CREATE_INFO,
    ERROR_INTERNAL,  // Should not have to use this, find more explicit errors where this one is used
    ERROR_INVALID_CONFIG,
    ERROR_INVALID_BOUNDS,
    ERROR_INVALID_GRAPH,
    ERROR_WEIGHT_OVERFLOW,
    ERROR_INVALID_ARGUMENT,
    ERROR_INVALID_CONTEXT
};

export function generateClusters(input: Input, clusterStorage: ClusterStorage): Result {
    let info: ClusterGetRequirementsInfo = new ClusterGetRequirementsInfo();
    info.input = input;

    let reqs: Requirements = new Requirements();
    let result: Result = nvclusterGetRequirements(info, reqs);

    if (result != Result.SUCCESS) {
        return result;
    }

    resizeArray(clusterStorage.clusterRanges, reqs.maxClusterCount, () => new Range());
    resizeArray(clusterStorage.clusterItems, reqs.maxClusteredElementCount, () => 0);

    let createInfo: ClusterCreateInfo = new ClusterCreateInfo();
    createInfo.input = input;

    let clusters: Output = new Output();
    clusters.clusteredElementIndices = clusterStorage.clusterItems;
    clusters.clusterRanges = clusterStorage.clusterRanges;
    clusters.clusterCount = reqs.maxClusterCount;
    clusters.clusteredElementIndexCount = reqs.maxClusteredElementCount;
    result = nvclusterCreate(createInfo, clusters);

    if (result == Result.SUCCESS) {
        resizeArray(clusterStorage.clusterRanges, clusters.clusterCount, () => new Range());
        resizeArray(clusterStorage.clusterItems, clusters.clusteredElementIndexCount, () => 0);
    }
    return result;
}

function nvclusterGetRequirements(info: ClusterGetRequirementsInfo, requirements: Requirements): Result {
    if (requirements == undefined) {
        return Result.ERROR_INVALID_ARGUMENT;
    }

    if (info.input.config.minClusterSize == 0 || info.input.config.maxClusterSize == 0) {
        // FIXME: return error code
        requirements = new Requirements();
        return Result.ERROR_INVALID_CONFIG;
    }
    const n = info.input.spatialElements.elementCount;
    const Ca = info.input.config.minClusterSize;
    const P = info.input.config.preSplitThreshold;
    const P_underfill = P == 0 ? 0 : (n + P - 1) / P;
    const maxClusters = (n + Ca - 1) / Ca + P_underfill;


    requirements.maxClusteredElementCount = Math.floor(n);
    requirements.maxClusterCount = Math.floor(maxClusters);

    return Result.SUCCESS;
}

export function nvclusterGetRequirementsSegmented(info: ClusterGetRequirementsSegmentedInfo, requirements: Requirements): Result {
    if (requirements == undefined) {
        return Result.ERROR_INVALID_ARGUMENT;
    }

    requirements.maxClusterCount = 0;
    requirements.maxClusteredElementCount = 0;

    for (let itemSegmentIndex = 0; itemSegmentIndex < info.elementSegmentCount; itemSegmentIndex++) {
        const range: Range = info.elementSegments[itemSegmentIndex];

        let segmentInfo: ClusterGetRequirementsInfo = new ClusterGetRequirementsInfo();
        let segmentInput: Input = new Input();
        let segmentBounds = new SpatialElements();
        segmentInput.config = info.input.config;
        segmentBounds.elementCount = range.count;
        segmentInput.spatialElements = segmentBounds;
        segmentInfo.input = segmentInput;

        let segmentResult: Requirements = new Requirements();
        let res: Result = nvclusterGetRequirements(segmentInfo, segmentResult);
        if (res != Result.SUCCESS) {
            return res;
        }
        requirements.maxClusterCount += segmentResult.maxClusterCount;
        requirements.maxClusteredElementCount += segmentResult.maxClusteredElementCount;
    }
    return Result.SUCCESS;
}

export function nvclusterCreate(info: ClusterCreateInfo, clusters: Output): Result {

    if (info == undefined || info.input == undefined || info.input.spatialElements == undefined) {
        return Result.ERROR_INVALID_CREATE_INFO;
    }

    let result: Result = clusterize(info.input, clusters);
    return result;
}

export function nvclustersCreateSegmented(info: ClusterCreateSegmentedInfo, clusters: Output, clusterSegments: Range[]): Result {
    let sizes = new Requirements();

    for (let segmentIndex = 0; segmentIndex < info.elementSegmentCount; segmentIndex++) {
        const range: Range = info.elementSegments[segmentIndex];
        let segmentInput = new Input();
        let segmentBounds: SpatialElements = new SpatialElements();
        // segmentBounds.boundingBoxes  = info.input.spatialElements.boundingBoxes + range.offset;
        // segmentBounds.centroids      = info.input.spatialElements.centroids + 3 * range.offset;
        segmentBounds.boundingBoxes = info.input.spatialElements.boundingBoxes.slice(range.offset);
        segmentBounds.centroids = info.input.spatialElements.centroids.slice(3 * range.offset);
        segmentBounds.elementCount = range.count;
        segmentInput.spatialElements = segmentBounds;
        segmentInput.config = info.input.config;
        segmentInput.graph = info.input.graph;

        if (sizes.maxClusteredElementCount + range.count > clusters.clusteredElementIndexCount) {
            return Result.ERROR_INTERNAL;
        }

        let segmentedOutput: Output = new Output()
        segmentedOutput.clusterRanges = createArrayView(clusters.clusterRanges, sizes.maxClusterCount, clusters.clusterCount - sizes.maxClusterCount);
        // segmentedOutput.clusterRanges = clusters.clusterRanges.slice(sizes.maxClusterCount);
        segmentedOutput.clusteredElementIndices = createArrayView(clusters.clusteredElementIndices, sizes.maxClusteredElementCount, clusters.clusteredElementIndexCount - sizes.maxClusteredElementCount);
        // segmentedOutput.clusteredElementIndices = clusters.clusteredElementIndices.slice(sizes.maxClusteredElementCount);
        segmentedOutput.clusterCount = clusters.clusterCount - sizes.maxClusterCount;
        segmentedOutput.clusteredElementIndexCount = range.count;


        if (segmentInput.spatialElements == undefined) {
            return Result.ERROR_INVALID_BOUNDS;
        }


        let result: Result = clusterize(segmentInput, segmentedOutput);

        if (result != Result.SUCCESS) {
            return result;
        }

        if (sizes.maxClusterCount + segmentedOutput.clusterCount > clusters.clusterCount) {
            return Result.ERROR_INTERNAL;
        }

        // Translate local ranges offsets and item indices to global
        for (let rangeIndex = 0; rangeIndex < segmentedOutput.clusterCount; rangeIndex++) {
            const clusterRange: Range = segmentedOutput.clusterRanges[rangeIndex];
            clusterRange.offset += sizes.maxClusteredElementCount;
        }

        for (let itemIndex = 0; itemIndex < segmentedOutput.clusteredElementIndexCount; itemIndex++) {
            segmentedOutput.clusteredElementIndices[itemIndex] += range.offset;
        }
        
        // Emit the segment of clustered items
        clusterSegments[segmentIndex] = new Range(sizes.maxClusterCount, segmentedOutput.clusterCount);
        sizes.maxClusterCount += segmentedOutput.clusterCount;
        sizes.maxClusteredElementCount += segmentedOutput.clusteredElementIndexCount;

        // console.log(`-----------------`);
        // console.log(`clusterSegments: [ Range { offset: ${clusterSegments[0].offset}, count: ${clusterSegments[0].count}}]`);
        // console.log(`clusters1111 Output2 {`);
        // console.log(`  clusterRanges: [ Range { offset: ${clusters.clusterRanges[0].offset}, count: ${clusters.clusterRanges[0].count}}, Range { offset: ${clusters.clusterRanges[1] ? clusters.clusterRanges[1].offset : 0}, count: ${clusters.clusterRanges[1] ? clusters.clusterRanges[1].count : 0}} ]`);
        // console.log(`  clusteredElementIndices: [ ${clusters.clusteredElementIndices[0]}, ${clusters.clusteredElementIndices[1]}, ${clusters.clusteredElementIndices[2]}, ${clusters.clusteredElementIndices[3]} ]`);
        // console.log(`  clusterCount: ${clusters.clusterCount}`);
        // console.log(`  clusteredElementIndexCount: ${clusters.clusteredElementIndexCount}`);
        // console.log(`}`);
        // console.log(`segmentedOutput1111 Output2 {`);
        // console.log(`  clusterRanges: [ Range { offset: ${segmentedOutput.clusterRanges[0].offset}, count: ${segmentedOutput.clusterRanges[0].count}}, Range { offset: ${segmentedOutput.clusterRanges[1] ? segmentedOutput.clusterRanges[1].offset : 0}, count: ${segmentedOutput.clusterRanges[1] ? segmentedOutput.clusterRanges[1].count : 0}} ]`);
        // console.log(`  clusteredElementIndices: [ ${segmentedOutput.clusteredElementIndices[0]}, ${segmentedOutput.clusteredElementIndices[1]}, ${segmentedOutput.clusteredElementIndices[2]}, ${segmentedOutput.clusteredElementIndices[3]} ]`);
        // console.log(`  clusterCount: ${segmentedOutput.clusterCount}`);
        // console.log(`  clusteredElementIndexCount: ${segmentedOutput.clusteredElementIndexCount}`);
        // console.log(`}`);
        // console.log(`-----------------`);
    }


    /*********************************************/

    clusters.clusteredElementIndexCount = sizes.maxClusteredElementCount;
    clusters.clusterCount = sizes.maxClusterCount;

    return Result.SUCCESS;
}