var SkyAtmosphereWGSL = "// From: https://www.shadertoy.com/view/msXXDS\n\n#include \"@trident/plugins/Sky/resources/Common.wgsl\";\n#include \"@trident/plugins/Sky/resources/Vertex.wgsl\";\n\n@group(0) @binding(1) var textureSampler: sampler;\n@group(0) @binding(2) var TransmittanceLUTTexture: texture_2d<f32>;\n\nconst M = mat4x3<f32>(\n    137.672389239975, -8.632904716299537, -1.7181567391931372,\n    32.549094028629234, 91.29801417199785, -12.005406444382531,\n    -38.91428392614275, 34.31665471469816, 29.89044807197628,\n    8.572844237945445, -11.103384660054624, 117.47585277566478\n);\n\nfn linear_srgb_from_spectral_samples(L: vec4f) -> vec3f {\n    return M * L;\n}\n\nfn get_multiple_scattering(transmittance_lut: texture_2d<f32>, cos_theta: f32, normalized_height: f32, d: f32) -> vec4f {\n// #if ENABLE_MULTIPLE_SCATTERING == 1\n    // Solid angle subtended by the planet from a point at d distance\n    // from the planet center.\n    let omega = 2.0 * PI * (1.0 - sqrt(d*d - EARTH_RADIUS*EARTH_RADIUS) / d);\n\n    let T_to_ground = transmittance_from_lut(transmittance_lut, cos_theta, 0.0);\n\n    let T_ground_to_sample = transmittance_from_lut(transmittance_lut, 1.0, 0.0) / transmittance_from_lut(transmittance_lut, 1.0, normalized_height);\n\n    // 2nd order scattering from the ground\n    let L_ground = PHASE_ISOTROPIC * omega * (GROUND_ALBEDO / PI) * T_to_ground * T_ground_to_sample * cos_theta;\n\n    // Fit of Earth's multiple scattering coming from other points in the atmosphere\n    let L_ms = 0.006 * vec4(0.217, 0.347, 0.594, 1.0) * (1.0 / (1.0 + 5.0 * exp(-17.92 * cos_theta)));\n\n    return L_ground;\n// #else\n//     return vec4(0.0);\n// #endif\n}\n\n/*\n* Helper function to obtain the transmittance to the top of the atmosphere\n* from Buffer A.\n*/\nfn transmittance_from_lut(lut: texture_2d<f32>, cos_theta: f32, normalized_altitude: f32) -> vec4f {\n    let u = clamp(cos_theta * 0.5 + 0.5, 0.0, 1.0);\n    let v = clamp(normalized_altitude, 0.0, 1.0);\n    return textureSampleLevel(lut, textureSampler, vec2(u, v), 0.0);\n}\n\n/*\n* Rayleigh phase function.\n*/\nfn molecular_phase_function(cos_theta: f32) -> f32\n{\n    return RAYLEIGH_PHASE_SCALE * (1.0 + cos_theta*cos_theta);\n}\n\n/*\n* Henyey-Greenstrein phase function.\n*/\nfn aerosol_phase_function(cos_theta: f32) -> f32\n{\n    let den = 1.0 + gg + 2.0 * g * cos_theta;\n    return INV_4PI * (1.0 - gg) / (den * sqrt(den));\n}\n    \nfn get_sun_direction() -> vec3f {\n    let elevation = radians(params.SUN_ELEVATION_DEGREES);\n    let azimuth   = radians(params.SUN_AZIMUTH_DEGREES);\n\n    let cos_zenith = cos(radians(90.0) - elevation);\n    let sin_zenith = sin(radians(-90.0) - elevation);\n\n    let x = sin_zenith * cos(azimuth);\n    let y = sin_zenith * sin(azimuth);\n    let z = cos_zenith;\n\n    return vec3(x, y, z);\n}\n\nstruct ComputeInscattering {\n    transmittance: vec4f,\n    L_inscattering: vec4f\n};\n\nfn compute_inscattering(ray_origin: vec3f, ray_dir: vec3f, t_d: f32) -> ComputeInscattering {\n    var out: ComputeInscattering;\n\n    let sun_dir = get_sun_direction();\n    let cos_theta = dot(-ray_dir, sun_dir);\n\n    let molecular_phase = molecular_phase_function(cos_theta);\n    let aerosol_phase = aerosol_phase_function(cos_theta);\n\n    let dt = t_d / f32(IN_SCATTERING_STEPS);\n\n    var L_inscattering = vec4(0.0);\n    var transmittance = vec4(1.0);\n\n    for (var i: i32 = 0; i < IN_SCATTERING_STEPS; i++) {\n        let t = (f32(i) + 0.5) * dt;\n        let x_t = ray_origin + ray_dir * t;\n\n        let distance_to_earth_center = length(x_t);\n        let zenith_dir = x_t / distance_to_earth_center;\n        let altitude = distance_to_earth_center - EARTH_RADIUS;\n        let normalized_altitude = altitude / ATMOSPHERE_THICKNESS;\n\n        let sample_cos_theta = dot(zenith_dir, sun_dir);\n\n        let collisionCoefficients = get_atmosphere_collision_coefficients(altitude);\n\n        let aerosol_absorption = collisionCoefficients.aerosol_absorption;\n        let aerosol_scattering = collisionCoefficients.aerosol_scattering;\n        let molecular_absorption = collisionCoefficients.molecular_absorption;\n        let molecular_scattering = collisionCoefficients.molecular_scattering;\n        let extinction = collisionCoefficients.extinction;\n\n        let transmittance_to_sun = transmittance_from_lut(TransmittanceLUTTexture, sample_cos_theta, normalized_altitude);\n\n        let ms = get_multiple_scattering(TransmittanceLUTTexture, sample_cos_theta, normalized_altitude, distance_to_earth_center);\n\n        let S = sun_spectral_irradiance * (molecular_scattering * (molecular_phase * transmittance_to_sun + ms) + aerosol_scattering   * (aerosol_phase   * transmittance_to_sun + ms));\n\n        let step_transmittance = exp(-dt * extinction);\n\n        // Energy-conserving analytical integration\n        // \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\"\n        // by SÃ©bastien Hillaire\n        let S_int = (S - S * step_transmittance) / max(extinction, vec4f(1e-7));\n        L_inscattering += transmittance * S_int;\n        transmittance *= step_transmittance;\n    }\n\n    out.L_inscattering = L_inscattering;\n    return out;\n}\n    \n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {\n    let uv = input.uv;\n\n    let azimuth = 2.0 * PI * uv.x;\n\n    // Apply a non-linear transformation to the elevation to dedicate more\n    // texels to the horizon, where having more detail matters.\n    let l = uv.y * 2.0 - 1.0;\n    let elev = l*l * sign(l) * PI * 0.5; // [-pi/2, pi/2]\n\n    let ray_dir = vec3(cos(elev) * cos(azimuth), cos(elev) * sin(azimuth), sin(elev));\n\n    let EYE_DISTANCE_TO_EARTH_CENTER = EARTH_RADIUS + params.EYE_ALTITUDE;\n    var ray_origin = vec3(0.0, 0.0, EYE_DISTANCE_TO_EARTH_CENTER);\n\n    let atmos_dist  = ray_sphere_intersection(ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n    let ground_dist = ray_sphere_intersection(ray_origin, ray_dir, EARTH_RADIUS);\n    var t_d: f32;\n    if (params.EYE_ALTITUDE < ATMOSPHERE_THICKNESS) {\n        // We are inside the atmosphere\n        if (ground_dist < 0.0) {\n            // No ground collision, use the distance to the outer atmosphere\n            t_d = atmos_dist;\n        } else {\n            // We have a collision with the ground, use the distance to it\n            t_d = ground_dist;\n        }\n    } else {\n        // We are in outer space\n        if (atmos_dist < 0.0) {\n            // No collision with the atmosphere, just return black\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            // Move the ray origin to the atmosphere intersection\n            ray_origin = ray_origin + ray_dir * (atmos_dist + 1e-3);\n            if (ground_dist < 0.0) {\n                // No collision with the ground, so the ray is exiting through\n                // the atmosphere.\n                let second_atmos_dist = ray_sphere_intersection(ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n                t_d = second_atmos_dist;\n            } else {\n                t_d = ground_dist - atmos_dist;\n            }\n        }\n    }\n\n    let inscattering = compute_inscattering(ray_origin, ray_dir, t_d);\n    let L = inscattering.L_inscattering;\n    let transmittance = inscattering.transmittance;\n\n// #if ENABLE_SPECTRAL == 1\n    // TODO: Adding tonemapping here as the sky seems way to overexposed, probably a bug somewhere else on the pipeline but original shader also under exposes\n    let col = linear_srgb_from_spectral_samples(L) * exp2(-4.0);\n    return vec4(col, 1.0);\n// #else\n//     return vec4(L.rgb, 1.0);\n// #endif\n}";

export { SkyAtmosphereWGSL as default };
