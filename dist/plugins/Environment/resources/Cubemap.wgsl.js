var CubemapWGSL = "@group(0) @binding(1) var hdrTexture: texture_2d<f32>;\n@group(0) @binding(2) var hdrSampler: sampler;\n\n@group(0) @binding(3) var<storage, read> face: vec4<f32>;\n\nstruct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };\n\n@vertex\nfn vertexMain(@location(0) position: vec3f) -> VSOut {\n    var o: VSOut;\n    o.pos = vec4f(position.xy, 0.0, 1.0);\n    o.uv  = position.xy; // [-1,1]\n    return o;\n}\n\nfn dirFromFaceUV(face: u32, x: f32, y: f32) -> vec3f {\n    let u = x;\n    let v = y;\n    switch face {\n        case 0u { return normalize(vec3( 1.0,  v, -u)); } // +X\n        case 1u { return normalize(vec3(-1.0,  v,  u)); } // -X\n        case 2u { return normalize(vec3( u,  1.0, -v)); } // +Y\n        case 3u { return normalize(vec3( u, -1.0,  v)); } // -Y\n        case 4u { return normalize(vec3( u,  v,  1.0)); } // +Z\n        default { return normalize(vec3(-u,  v, -1.0)); } // -Z\n    }\n}\n\n\nconst PI = 3.14159265358979323846;\nconst INV_PI = 0.31830988618379067154;\nfn sampleSkyViewLUT(v: vec3f) -> vec2f {\n    let azimuth = atan2(v.z, v.x) * 0.5 * INV_PI + 0.5;\n    let elev    = asin(v.y);\n    let signElev = select(-1.0, 1.0, elev >= 0.0);\n    let t = sqrt(abs(elev) / (0.5 * PI));\n    let lutV = 0.5 * (signElev * t + 1.0);\n    return vec2(azimuth, lutV);\n}\n\n// @fragment\n// fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {\n//     let pix   = vec2<i32>(floor(input.position.xy));\n\n//     let depth = textureLoad(depthTexture, pix, 0);\n    \n//     if (depth <= 0.9999999) {\n//         discard;\n//     }\n\n//     let uv = input.position.xy / view.projectionOutputSize.xy;\n//     let fragCoord = uv * view.projectionOutputSize.xy;\n//     let camera = compute_camera_angles(fragCoord, view.projectionOutputSize.xy);\n\n\n//     let azimuth = camera.phi / PI * 0.5 + 0.5;\n//     // Undo the non-linear transformation from the sky-view LUT\n//     let elev = sqrt(abs(camera.theta) / (PI * 0.5)) * sign(camera.theta) * 0.5 + 0.5;\n\n//     let col = textureSample(skyboxTexture, textureSampler, vec2(azimuth, elev)).rgb;\n//     return vec4f(col, 1.0);\n// }\n\n@fragment\nfn fragmentMain(@location(0) uv: vec2f) -> @location(0) vec4f {\n    let dir = dirFromFaceUV(u32(face.x), uv.x, uv.y);\n    let st  = sampleSkyViewLUT(dir);\n    let col = textureSample(hdrTexture, hdrSampler, st).rgb;\n    return vec4f(col, 1.0);\n}";

export { CubemapWGSL as default };
