var WGSL_Shader_Deferred_ShadowUtils = "struct ShadowCSM {\n    visibility: f32,\n    selectedCascade: i32\n};\n\n// ---------- helpers ----------\n\nfn inUnitSquare(u: vec2<f32>) -> bool {\n    return all(u >= vec2<f32>(0.0)) && all(u <= vec2<f32>(1.0));\n}\n\n// Center tap early-accept + unrolled 3×3 PCF (fast path)\nfn pcf3x3_quadrant(\n    uv: vec2<f32>, z: f32, layer: i32, texel: vec2<f32>\n) -> f32 {\n    // Early accept: fully lit center → 1.0\n    let center = textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv, layer, z);\n    if (center >= 1.0) { return 1.0; }\n\n    var sum = 0.0;\n    // Row -1\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x, -texel.y), layer, z);\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(         0.0, -texel.y), layer, z);\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x, -texel.y), layer, z);\n    // Row  0\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x,          0.0), layer, z);\n    sum += center;\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x,          0.0), layer, z);\n    // Row +1\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x,  texel.y), layer, z);\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(         0.0,  texel.y), layer, z);\n    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x,  texel.y), layer, z);\n\n    return sum * (1.0 / 9.0);\n}\n\n// Optional: bounded dynamic radius (clamped to MAX_RADIUS to avoid explosions)\nconst MAX_RADIUS : i32 = 2; // up to 5×5\nfn pcfBounded(\n    uv: vec2<f32>, z: f32, layer: i32, texel: vec2<f32>, radius: i32\n) -> f32 {\n    let r = clamp(radius, 0, MAX_RADIUS);\n    if (r <= 1) { return pcf3x3_quadrant(uv, z, layer, texel); }\n\n    var sum = 0.0;\n    for (var j = -r; j <=  r; j = j + 1) {\n        for (var i = -r; i <=  r; i = i + 1) {\n            sum += textureSampleCompareLevel(\n                shadowPassDepth, shadowSamplerComp,\n                uv + vec2<f32>(f32(i), f32(j)) * texel,\n                layer, z\n            );\n        }\n    }\n    let taps = f32((2 * r + 1) * (2 * r + 1));\n    return sum / taps;\n}";

export { WGSL_Shader_Deferred_ShadowUtils as default };
