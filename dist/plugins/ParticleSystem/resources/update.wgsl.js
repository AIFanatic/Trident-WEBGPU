var WGSL_Compute = "#include \"@trident/plugins/ParticleSystem/resources/structs.wgsl\";\n\n@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;\n@group(0) @binding(1) var<storage, read> settings: SystemSettings;\n\nconst PI: f32 = 3.141592653589793;\n\n// 1D: hash a single float -> [0,1)\nfn hash11(n: f32) -> f32 {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfn rng3(seed: f32, idx: u32) -> vec3<f32> {\n    let i = f32(idx);\n    return vec3(\n        hash11(seed + i * 1.0),\n        hash11(seed + i * 2.0),\n        hash11(seed + i * 3.0)\n    );\n}\n\nfn onUnitSphere(u: vec2<f32>) -> vec3<f32> {\n    // uniform over sphere surface\n    let z = 1.0 - 2.0 * u.x;\n    let a = 2.0 * PI * u.y;\n    let r = sqrt(max(0.0, 1.0 - z*z));\n    return vec3(r * cos(a), r * sin(a), z);\n}\nfn inUnitSphere(u: vec3<f32>) -> vec3<f32> {\n    // uniform in volume via r^(1/3)\n    let dir = onUnitSphere(u.xy);\n    let r = pow(u.z, 1.0 / 3.0);\n    return dir * r;\n}\nfn hemi(dir: vec3<f32>) -> vec3<f32> {\n    // keep +Y hemisphere (like Unity default)\n    return vec3(dir.x, abs(dir.y), dir.z);\n}\nfn coneDir(u: vec2<f32>, angle: f32) -> vec3<f32> {\n    // uniform within a cone around +Y\n    let cosMax = cos(angle);\n    let cosT = mix(cosMax, 1.0, u.x);\n    let sinT = sqrt(1.0 - cosT*cosT);\n    let phi  = 2.0 * PI * u.y;\n    return vec3(sinT * cos(phi), cosT, sinT * sin(phi));\n}\n\nfn resetParticle(idx: u32, _p: Particle, grid: vec3<f32>) -> Particle {\n    var p = _p;\n\n    let r3 = rng3(1337.0, idx);        // base RNG\n    let r3b = rng3(7331.0, idx);       // secondary RNG\n    var pos = settings.emitterPosition.xyz;\n    var dir = vec3(0.0);\n\n    // Sphere / HemiSphere\n    let shapeType = u32(settings.shapeType);\n    if (shapeType == 0u || shapeType == 1u) {\n        let d = onUnitSphere(r3.xy);\n        let dH = select(d, hemi(d), shapeType == 1u);\n        let r = select(pow(r3.z, 1.0/3.0), 1.0, settings.emitFromShell > 0.5);\n        pos = pos + dH * settings.radius * r;\n        dir = normalize(dH);\n    }\n\n    // Cone (around +Y, apex at emitterPosition)\n    if (shapeType == 2u) {\n        let d = coneDir(r3.xy, settings.coneAngle);\n        // spawn along cone axis (optional), cheap & decent:\n        let h = settings.coneHeight * r3.z;\n        pos = pos + vec3(0.0, h, 0.0) + d * settings.radius;   // radius acts like “base radius”\n        dir = normalize(d);\n    }\n\n    // Box (centered at emitterPosition)\n    if (shapeType == 3u) {\n        let q = (r3 * 2.0 - 1.0) * settings.boxHalfExtents;\n        pos = pos + q;\n        // shoot outward from center or random unit:\n        dir = normalize(select(q, onUnitSphere(r3b.xy), length(q) > 1e-5));\n    }\n\n    p.position = vec4f(pos, 1.0);\n    // p.velocity = vec4(dir, settings.startSize);\n    p.velocity = vec4(dir * settings.startSpeed.xyz, settings.startSize);\n    p.age.y = settings.startLifetime * 1000.0;\n    p.age.w = 1.0;\n    p.texture.x = floor(hash11(settings.timeMs * settings.dt * pos.x * pos.y * pos.z) * settings.tiles.x * settings.tiles.y);\n    return p;\n}\n\nconst blockSize: u32 = 4;\n\n@compute @workgroup_size(blockSize, blockSize, blockSize)\nfn main(@builtin(global_invocation_id) grid: vec3<u32>,\n        @builtin(num_workgroups) numWg: vec3<u32>) {\n\n    let N: u32 = u32(settings.instanceCount);\n\n    let dimX = numWg.x * blockSize;\n    let dimY = numWg.y * blockSize;\n    let idx  = grid.x + grid.y * dimX + grid.z * dimX * dimY;\n    if (idx >= N) { return; }\n\n    var p = particles[idx];\n\n    // N = particle count, idx = this particle index\n    let rate = max(settings.rateOverTime, 1e-4);\n    let win  = f32(N) / rate;          // window length in seconds (units cancel out anyway)\n    \n    // normalized times in [0,1)\n    let t0 = fract((settings.timeMs - settings.dt) / (win * 1000.0));\n    let t1 = fract( settings.timeMs              / (win * 1000.0));\n    var span = t1 - t0;\n    span = span + select(0.0, 1.0, span < 0.0);   // wrap-safe span in (0,1]\n    \n    // per-particle phase in [0,1)\n    let phase = f32(idx) / f32(N);\n    var rel = phase - t0;\n    rel = rel + select(0.0, 1.0, rel <= 0.0);     // distance from t0 to phase, wrap-safe\n    \n    let crossed = rel <= span;                    // true if phase hit this frame\n    \n\n    if (crossed) {\n        // (re)spawn this particle now\n        p = resetParticle(idx, p, vec3f(grid));\n        p.age.x = 0.0;                               // age ms\n        p.age.y = settings.startLifetime * 1000.0;   // life ms\n        p.age.w = 1.0;                               // alive flag\n    }\n\n    // --- simulate alive particles ---\n    let dt_s = settings.dt / 1000.0;\n\n    if (p.age.w >= 0.5) {\n        p.velocity += settings.gravity * dt_s;\n        p.position = vec4f(p.position.xyz + p.velocity.xyz * dt_s, 1.0);\n\n        p.age.x += settings.dt;\n        if (p.age.x >= p.age.y) { p.age.w = 0.0; }\n    }\n\n    particles[idx] = p;\n}";

export { WGSL_Compute as default };
