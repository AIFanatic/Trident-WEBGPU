var WGSL_Draw = "#include \"@trident/plugins/ParticleSystem/resources/structs.wgsl\";\n\nstruct VertexInput {\n    @builtin(instance_index) instanceIdx : u32, \n    @location(0) position : vec3<f32>,\n    @location(1) normal : vec3<f32>,\n    @location(2) uv : vec2<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) rawPosition: vec3<f32>,\n    @location(1) uv: vec2<f32>,\n    @location(2) @interpolate(flat) instanceIdx: u32\n};\n\n@group(0) @binding(0) var<storage, read> projectionMatrix: mat4x4<f32>;\n@group(0) @binding(1) var<storage, read> viewMatrix: mat4x4<f32>;\n@group(0) @binding(2) var<storage, read> modelMatrix: array<mat4x4<f32>>;\n@group(0) @binding(3) var<storage, read> particles: array<Particle>;\n@group(0) @binding(4) var texture: texture_2d<f32>;\n@group(0) @binding(5) var textureSampler: sampler;\n@group(0) @binding(6) var<storage, read> settings: SystemSettings;\n@group(0) @binding(7) var colorOverLifetimeRamp: texture_2d<f32>;\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output : VertexOutput;\n\n    let p = particles[input.instanceIdx];\n\n    if (p.age.w < 0.5) {\n        output.position = vec4(10000.0);\n        return output;\n    }\n\n    // size for the quad (use your own source: velocity.w, a size attribute, etc.)\n    let size = max(p.velocity.w, 0.001);\n\n    // Particle center in VIEW space\n    let centerVS = (viewMatrix * vec4(p.position.xyz, 1.0)).xyz;\n\n    // Vertex's local quad coords (e.g., [-0.5..0.5] or [-1..1])\n    let local = input.position.xy * size;\n\n    // In view space, Right=(1,0,0), Up=(0,1,0), already camera-aligned\n    let billboardVS = centerVS + vec3(local.x, local.y, 0.0);\n\n    // Project to clip space\n    output.position = projectionMatrix * vec4(billboardVS, 1.0);\n\n    output.rawPosition = input.position;\n    output.uv = input.uv;\n    output.instanceIdx = input.instanceIdx;\n    return output;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    let particle = particles[input.instanceIdx];\n\n    // let color = vec3(1.0);\n    // let a = clamp(1.0 - length(input.rawPosition), 0.0, 1.0); // no negatives\n    // // optional: hard discard to avoid touching the background at all\n    // // if (a <= 0.0) { discard; }\n    // return vec4(color * a, a); // premultiplied\n\n    if (length(input.rawPosition) > 1.0) {\n        discard;\n    }\n    \n    var color = vec4f(1.0);\n\n    let t = particle.age.x / particle.age.y;\n    // color = mix(settings.colorOverLifetime0, settings.colorOverLifetime1, t);\n    color = textureSample(colorOverLifetimeRamp, textureSampler, vec2<f32>(clamp(t,0.0,1.0), 0.5));\n\n    if (bool(settings.hasTexture)) {\n\n        var tileIndex = 0.0;\n        if (u32(settings.frameOvertime) == 0) {}\n        else if (u32(settings.frameOvertime) == 1) { tileIndex = mix(0.0, settings.tiles.x * settings.tiles.y, t); }\n        else if (u32(settings.frameOvertime) == 2) { tileIndex = particle.texture.x; }\n\n        let scale = 1.0 / vec2<f32>(settings.tiles.xy);\n        let tx = floor(tileIndex % settings.tiles.x);      // 0..cols-1\n        let ty = floor(tileIndex / settings.tiles.x);      // 0..rows-1  <-- NOTE: divide by cols\n        let tileOffset = vec2<f32>(tx, ty) * scale;\n        color *= textureSample(texture, textureSampler, input.uv * scale + tileOffset);\n        \n        // if (length(color) < 0.001) {\n        //     discard; // TODO: Blend\n        // }\n    }\n\n    // return color;\n    return vec4f(color.rgb * color.a, color.a);\n}";

export { WGSL_Draw as default };
