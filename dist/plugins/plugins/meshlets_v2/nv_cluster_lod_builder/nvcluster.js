import { clusterize } from './clusterizer.js';
import { resizeArray, createArrayView } from './nvclusterlod_common.js';

class Range {
  offset = 0;
  count = 0;
  constructor(offset = 0, count = 0) {
    this.offset = offset;
    this.count = count;
  }
}
class Config {
  // Minimum number of elements contained in a cluster
  minClusterSize = 1;
  // Maximum number of elements contained in a cluster
  maxClusterSize = -1;
  // Cost penalty for under-filling clusters
  costUnderfill = 1;
  // Cost penalty for overlapping bounding boxes
  costOverlap = 0.01;
  // If nonzero the set of input elements will first be split along its median
  // until each subset contains at most preSplitThreshold elements prior to actual
  // clustering. This is an optimization intended to speed up clustering of large
  // sets of elements
  preSplitThreshold = 0;
}
class AABB {
  bboxMin = [Infinity, Infinity, Infinity];
  bboxMax = [-Infinity, -Infinity, -Infinity];
  constructor(bboxMin = [Infinity, Infinity, Infinity], bboxMax = [-Infinity, -Infinity, -Infinity]) {
    this.bboxMin = bboxMin;
    this.bboxMax = bboxMax;
  }
}
class SpatialElements {
  // Bounding boxes of elements to cluster
  boundingBoxes;
  // Center positions (xyz) of elements to cluster
  centroids;
  // Number of elements
  elementCount = 0;
}
class Graph {
  // Each node is defined by its connections to other nodes, stored at node.offset in connectionTargets. Each node has node.count connections
  nodes;
  // Total number of nodes in the graph
  nodeCount = 0;
  // Connection targets for the nodes, referenced by nodes
  connectionTargets;
  // Weight of each connection
  connectionWeights;
  // Total number of connections in the graph
  connectionCount = 0;
}
class Input {
  // Clustering configuration
  config = new Config();
  // Set of elements to cluster, required
  spatialElements = new SpatialElements();
  // Optional graph defining the weighted connectivity between elements, used to optimize a cost function
  // when clustering
  graph;
}
class ClusterGetRequirementsSegmentedInfo {
  // Input elements to cluster
  input;
  // Each segment is defined by a range within the array of elements defined in input
  elementSegments;
  // Number of segments
  elementSegmentCount = 0;
}
class ClusterGetRequirementsInfo {
  // Input elements to cluster
  input;
}
class ClusterCreateSegmentedInfo {
  input;
  // Each segment is defined by a range within the array of elements defined in input
  elementSegments;
  // Number of segments
  elementSegmentCount = 0;
}
class Output {
  // Clusters defined by ranges of element indices, where each cluster starts at range.offset in clusteredElementIndices and contains range.count elements
  clusterRanges;
  // Indices of the elements, referenced by clusterRanges
  clusteredElementIndices;
  // Total number of clusters generated by the clustering (may be less than maxClusterCount)
  clusterCount = 0;
  // Total number of cluster element indices (FIXME why, shouldn't this be the same as the input?)
  clusteredElementIndexCount = 0;
}
class Requirements {
  // Maximum number of generated clusters
  maxClusterCount = 0;
  // Maximum total number of elements referenced by the clusters
  maxClusteredElementCount = 0;
}
class ClusterCreateInfo {
  // Input elements to cluster
  input;
}
var Result = /* @__PURE__ */ ((Result2) => {
  Result2[Result2["SUCCESS"] = 0] = "SUCCESS";
  Result2[Result2["ERROR_INVALID_CREATE_INFO"] = 1] = "ERROR_INVALID_CREATE_INFO";
  Result2[Result2["ERROR_INTERNAL"] = 2] = "ERROR_INTERNAL";
  Result2[Result2["ERROR_INVALID_CONFIG"] = 3] = "ERROR_INVALID_CONFIG";
  Result2[Result2["ERROR_INVALID_BOUNDS"] = 4] = "ERROR_INVALID_BOUNDS";
  Result2[Result2["ERROR_INVALID_GRAPH"] = 5] = "ERROR_INVALID_GRAPH";
  Result2[Result2["ERROR_WEIGHT_OVERFLOW"] = 6] = "ERROR_WEIGHT_OVERFLOW";
  Result2[Result2["ERROR_INVALID_ARGUMENT"] = 7] = "ERROR_INVALID_ARGUMENT";
  Result2[Result2["ERROR_INVALID_CONTEXT"] = 8] = "ERROR_INVALID_CONTEXT";
  return Result2;
})(Result || {});
function generateClusters(input, clusterStorage) {
  let info = new ClusterGetRequirementsInfo();
  info.input = input;
  let reqs = new Requirements();
  let result = nvclusterGetRequirements(info, reqs);
  if (result != 0 /* SUCCESS */) {
    return result;
  }
  resizeArray(clusterStorage.clusterRanges, reqs.maxClusterCount, () => new Range());
  resizeArray(clusterStorage.clusterItems, reqs.maxClusteredElementCount, () => 0);
  let createInfo = new ClusterCreateInfo();
  createInfo.input = input;
  let clusters = new Output();
  clusters.clusteredElementIndices = clusterStorage.clusterItems;
  clusters.clusterRanges = clusterStorage.clusterRanges;
  clusters.clusterCount = reqs.maxClusterCount;
  clusters.clusteredElementIndexCount = reqs.maxClusteredElementCount;
  result = nvclusterCreate(createInfo, clusters);
  if (result == 0 /* SUCCESS */) {
    resizeArray(clusterStorage.clusterRanges, clusters.clusterCount, () => new Range());
    resizeArray(clusterStorage.clusterItems, clusters.clusteredElementIndexCount, () => 0);
  }
  return result;
}
function nvclusterGetRequirements(info, requirements) {
  if (requirements == void 0) {
    return 7 /* ERROR_INVALID_ARGUMENT */;
  }
  if (info.input.config.minClusterSize == 0 || info.input.config.maxClusterSize == 0) {
    requirements = new Requirements();
    return 3 /* ERROR_INVALID_CONFIG */;
  }
  const n = info.input.spatialElements.elementCount;
  const Ca = info.input.config.minClusterSize;
  const P = info.input.config.preSplitThreshold;
  const P_underfill = P == 0 ? 0 : (n + P - 1) / P;
  const maxClusters = (n + Ca - 1) / Ca + P_underfill;
  requirements.maxClusteredElementCount = Math.floor(n);
  requirements.maxClusterCount = Math.floor(maxClusters);
  return 0 /* SUCCESS */;
}
function nvclusterGetRequirementsSegmented(info, requirements) {
  if (requirements == void 0) {
    return 7 /* ERROR_INVALID_ARGUMENT */;
  }
  requirements.maxClusterCount = 0;
  requirements.maxClusteredElementCount = 0;
  for (let itemSegmentIndex = 0; itemSegmentIndex < info.elementSegmentCount; itemSegmentIndex++) {
    const range = info.elementSegments[itemSegmentIndex];
    let segmentInfo = new ClusterGetRequirementsInfo();
    let segmentInput = new Input();
    let segmentBounds = new SpatialElements();
    segmentInput.config = info.input.config;
    segmentBounds.elementCount = range.count;
    segmentInput.spatialElements = segmentBounds;
    segmentInfo.input = segmentInput;
    let segmentResult = new Requirements();
    let res = nvclusterGetRequirements(segmentInfo, segmentResult);
    if (res != 0 /* SUCCESS */) {
      return res;
    }
    requirements.maxClusterCount += segmentResult.maxClusterCount;
    requirements.maxClusteredElementCount += segmentResult.maxClusteredElementCount;
  }
  return 0 /* SUCCESS */;
}
function nvclusterCreate(info, clusters) {
  if (info == void 0 || info.input == void 0 || info.input.spatialElements == void 0) {
    return 1 /* ERROR_INVALID_CREATE_INFO */;
  }
  let result = clusterize(info.input, clusters);
  return result;
}
function nvclustersCreateSegmented(info, clusters, clusterSegments) {
  let sizes = new Requirements();
  for (let segmentIndex = 0; segmentIndex < info.elementSegmentCount; segmentIndex++) {
    const range = info.elementSegments[segmentIndex];
    let segmentInput = new Input();
    let segmentBounds = new SpatialElements();
    segmentBounds.boundingBoxes = info.input.spatialElements.boundingBoxes.slice(range.offset);
    segmentBounds.centroids = info.input.spatialElements.centroids.slice(3 * range.offset);
    segmentBounds.elementCount = range.count;
    segmentInput.spatialElements = segmentBounds;
    segmentInput.config = info.input.config;
    segmentInput.graph = info.input.graph;
    if (sizes.maxClusteredElementCount + range.count > clusters.clusteredElementIndexCount) {
      return 2 /* ERROR_INTERNAL */;
    }
    let segmentedOutput = new Output();
    segmentedOutput.clusterRanges = createArrayView(clusters.clusterRanges, sizes.maxClusterCount, clusters.clusterCount - sizes.maxClusterCount);
    segmentedOutput.clusteredElementIndices = createArrayView(clusters.clusteredElementIndices, sizes.maxClusteredElementCount, clusters.clusteredElementIndexCount - sizes.maxClusteredElementCount);
    segmentedOutput.clusterCount = clusters.clusterCount - sizes.maxClusterCount;
    segmentedOutput.clusteredElementIndexCount = range.count;
    if (segmentInput.spatialElements == void 0) {
      return 4 /* ERROR_INVALID_BOUNDS */;
    }
    let result = clusterize(segmentInput, segmentedOutput);
    if (result != 0 /* SUCCESS */) {
      return result;
    }
    if (sizes.maxClusterCount + segmentedOutput.clusterCount > clusters.clusterCount) {
      return 2 /* ERROR_INTERNAL */;
    }
    for (let rangeIndex = 0; rangeIndex < segmentedOutput.clusterCount; rangeIndex++) {
      const clusterRange = segmentedOutput.clusterRanges[rangeIndex];
      clusterRange.offset += sizes.maxClusteredElementCount;
    }
    for (let itemIndex = 0; itemIndex < segmentedOutput.clusteredElementIndexCount; itemIndex++) {
      segmentedOutput.clusteredElementIndices[itemIndex] += range.offset;
    }
    clusterSegments[segmentIndex] = new Range(sizes.maxClusterCount, segmentedOutput.clusterCount);
    sizes.maxClusterCount += segmentedOutput.clusterCount;
    sizes.maxClusteredElementCount += segmentedOutput.clusteredElementIndexCount;
  }
  clusters.clusteredElementIndexCount = sizes.maxClusteredElementCount;
  clusters.clusterCount = sizes.maxClusterCount;
  return 0 /* SUCCESS */;
}

export { AABB, ClusterCreateInfo, ClusterCreateSegmentedInfo, ClusterGetRequirementsInfo, ClusterGetRequirementsSegmentedInfo, Config, Graph, Input, Output, Range, Requirements, Result, SpatialElements, generateClusters, nvclusterCreate, nvclusterGetRequirementsSegmented, nvclustersCreateSegmented };
