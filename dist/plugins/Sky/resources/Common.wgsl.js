var CommonWGSL = "// Configurable parameters\n\n// #define ANIMATE_SUN 1\n// // 0=equirectangular, 1=fisheye, 2=projection\n// #define CAMERA_TYPE 2\n// // 0=Background, 1=Desert Dust, 2=Maritime Clean, 3=Maritime Mineral,\n// // 4=Polar Antarctic, 5=Polar Artic, 6=Remote Continental, 7=Rural, 8=Urban\n// #define AEROSOL_TYPE 8\n\nstruct Params {\n    SUN_ELEVATION_DEGREES: f32,\n    EYE_ALTITUDE: f32,\n    pad0: f32,\n    pad1: f32,\n};\n@group(0) @binding(0) var<storage, read> params: Params;\n\n// const SUN_ELEVATION_DEGREES = 0.0;    // 0=horizon, 90=zenith\n// const EYE_ALTITUDE          = 0.5;    // km\nconst MONTH                 = 0;      // 0-11, January to December\nconst AEROSOL_TURBIDITY     = 1.0;\nconst GROUND_ALBEDO         = vec4(0.3);\n// Ray marching steps. More steps mean better accuracy but worse performance\nconst TRANSMITTANCE_STEPS     = 32;\nconst IN_SCATTERING_STEPS     = 32;\n\n// // Debug\n// #define ENABLE_SPECTRAL 1\n// #define ENABLE_MULTIPLE_SCATTERING 1\n// #define ENABLE_AEROSOLS 1\n// #define SHOW_RELATIVE_LUMINANCE 0\n// #define TONEMAPPING_TECHNIQUE 0 // 0=ACES, 1=simple\n\n// -----------------------------------------------------------------------------\n// Constants\n\n// All parameters that depend on wavelength (vec4) are sampled at\n// 630, 560, 490, 430 nanometers\n\nconst PI = 3.14159265358979323846;\nconst INV_PI = 0.31830988618379067154;\nconst INV_4PI = 0.25 * INV_PI;\nconst PHASE_ISOTROPIC = INV_4PI;\nconst RAYLEIGH_PHASE_SCALE = (3.0 / 16.0) * INV_PI;\nconst g = 0.8;\nconst gg = g*g;\n\nconst EARTH_RADIUS = 6371.0; // km\nconst ATMOSPHERE_THICKNESS = 100.0; // km\nconst ATMOSPHERE_RADIUS = EARTH_RADIUS + ATMOSPHERE_THICKNESS;\n// const EYE_DISTANCE_TO_EARTH_CENTER = EARTH_RADIUS + params.EYE_ALTITUDE;\n// const SUN_ZENITH_COS_ANGLE = cos(radians(90.0 - params.SUN_ELEVATION_DEGREES));\n// const SUN_DIR = vec3(-sqrt(1.0 - SUN_ZENITH_COS_ANGLE*SUN_ZENITH_COS_ANGLE), 0.0, SUN_ZENITH_COS_ANGLE);\n\n// #elif AEROSOL_TYPE == 8 // Urban\nconst aerosol_absorption_cross_section = vec4(2.8722e-24, 4.6168e-24, 7.9706e-24, 1.3578e-23);\nconst aerosol_scattering_cross_section = vec4(1.5908e-22, 1.7711e-22, 2.0942e-22, 2.4033e-22);\nconst aerosol_base_density = 1.3681e20;\nconst aerosol_background_density = 2e6;\nconst aerosol_height_scale = 0.73;\n\nconst aerosol_background_divided_by_base_density = aerosol_background_density / aerosol_base_density;\n\nconst ozone_mean_monthly_dobson = array<f32, 12>(\n    347.0, // January\n    370.0, // February\n    381.0, // March\n    384.0, // April\n    372.0, // May\n    352.0, // June\n    333.0, // July\n    317.0, // August\n    298.0, // September\n    285.0, // October\n    290.0, // November\n    315.0  // December\n);\n\nconst ozone_absorption_cross_section = vec4(3.472e-21, 3.914e-21, 1.349e-21, 11.03e-23) * 1e-4f;\nconst molecular_scattering_coefficient_base = vec4(6.605e-3, 1.067e-2, 1.842e-2, 3.156e-2);\n\n/*\n* Return the molecular volume scattering coefficient (km^-1) for a given altitude\n* in kilometers.\n*/\nfn get_molecular_scattering_coefficient(h: f32) -> vec4f {\n    return molecular_scattering_coefficient_base * exp(-0.07771971 * pow(h, 1.16364243));\n}\n    \n/*\n* Return the molecular volume absorption coefficient (km^-1) for a given altitude\n* in kilometers.\n*/\nfn get_molecular_absorption_coefficient(_h: f32) -> vec4f\n{\n    let h = _h + 1e-4; // Avoid division by 0\n    let t = log(h) - 3.22261;\n    let density = 3.78547397e20 * (1.0 / h) * exp(-t * t * 5.55555555);\n    return ozone_absorption_cross_section * ozone_mean_monthly_dobson[MONTH] * density;\n}\n\n/*\n* Returns the distance between ro and the first intersection with the sphere\n* or -1.0 if there is no intersection. The sphere's origin is (0,0,0).\n* -1.0 is also returned if the ray is pointing away from the sphere.\n*/\nfn ray_sphere_intersection(ro: vec3f, rd: vec3f, radius: f32) -> f32 {\n    let b = dot(ro, rd);\n    let c = dot(ro, ro) - radius*radius;\n    if (c > 0.0 && b > 0.0) { return -1.0; }\n    let d = b*b - c;\n    if (d < 0.0) { return -1.0; }\n    if (d > b*b) { return (-b+sqrt(d)); }\n    return (-b-sqrt(d));\n}\n\nfn get_aerosol_density(h: f32) -> f32 {\n// #if AEROSOL_TYPE == 0 // Only for the Background aerosol type, no dependency on height\n//     return aerosol_base_density * (1.0 + aerosol_background_divided_by_base_density);\n// #else\n    return aerosol_base_density * (exp(-h / aerosol_height_scale) + aerosol_background_divided_by_base_density);\n// #endif\n}\n\nstruct CollisionCoefficients {\n    aerosol_absorption: vec4f,\n    aerosol_scattering: vec4f,\n    molecular_absorption: vec4f,\n    molecular_scattering: vec4f,\n    extinction: vec4f\n};\n/*\n* Get the collision coefficients (scattering and absorption) of the\n* atmospheric medium for a given point at an altitude h.\n*/\nfn get_atmosphere_collision_coefficients(_h: f32) -> CollisionCoefficients {\n    var out: CollisionCoefficients;\n\n    let h = max(_h, 0.0); // In case height is negative\n// #if ENABLE_AEROSOLS == 0\n//     // out.aerosol_absorption = vec4(0.0);\n//     // out.aerosol_scattering = vec4(0.0);\n// #else\n    let aerosol_density = get_aerosol_density(h);\n    out.aerosol_absorption = aerosol_absorption_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n    out.aerosol_scattering = aerosol_scattering_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n// #endif\n    out.molecular_absorption = get_molecular_absorption_coefficient(h);\n    out.molecular_scattering = get_molecular_scattering_coefficient(h);\n    out.extinction = out.aerosol_absorption + out.aerosol_scattering + out.molecular_absorption + out.molecular_scattering;\n    \n    return out;\n}";

export { CommonWGSL as default };
