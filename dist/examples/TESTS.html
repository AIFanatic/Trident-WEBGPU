
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
            <meta name="mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-capable" content="yes">
            
            <style>
                html, body {
                    margin: 0;
                    overflow: hidden;
                    height: 100%;
                    width: 100%;
                }
            </style>
        </head>
        <body>
            <script type="importmap">
                {
                    "imports": {
                        "@trident/core": "../trident-core.js",
                        "@trident/plugins/": "../plugins/"
                    }
                }
            </script>
            <script type="module">
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                            const m = document.createElement("div");
            m.innerHTML = `<div id="ui">
                <label>Slice Z <input id="slice" type="range" min="0" max="127" value="64"></label>
                <span>Distance window: <span id="win" class="mono">[0.0, 0.2] m</span></span>
              </div>`;
            document.body.appendChild(m);
            const zSlider = (
              /** @type {HTMLInputElement} */
              document.getElementById("slice")
            );
            const winEl = document.getElementById("win");
            let visMin = 0, visMax = 0.2;
            const updateWinText = () => winEl.textContent = `[${visMin.toFixed(3)}, ${visMax.toFixed(3)}] m`;
            updateWinText();
            if (!("gpu" in navigator)) {
              document.body.innerHTML = '<h2 style="padding:20px">Your browser does not support WebGPU.</h2>';
              throw new Error("WebGPU not supported");
            }
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format: canvasFormat, alphaMode: "opaque" });
            async function buildSDF(device2, seeds2, dims2) {
              const { nx, ny, nz, voxelSize } = dims2;
              const voxelCount = nx * ny * nz;
              const bytesPerVoxel = 16;
              const gridA = device2.createBuffer({ size: voxelCount * bytesPerVoxel, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
              const gridB = device2.createBuffer({ size: voxelCount * bytesPerVoxel, usage: GPUBufferUsage.STORAGE });
              const params = device2.createBuffer({ size: 8 * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
              const seedData = new Uint32Array(seeds2.length * 4);
              for (let i = 0; i < seeds2.length; i++) {
                const s = seeds2[i];
                seedData[4 * i + 0] = s.x >>> 0;
                seedData[4 * i + 1] = s.y >>> 0;
                seedData[4 * i + 2] = s.z >>> 0;
                seedData[4 * i + 3] = 0;
              }
              const seedList = device2.createBuffer({ size: seedData.byteLength || 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
              if (seedData.byteLength) device2.queue.writeBuffer(seedList, 0, seedData);
              const sdfTex2 = device2.createTexture({
                size: { width: nx, height: ny, depthOrArrayLayers: nz },
                format: "r32float",
                dimension: "3d",
                // <-- REQUIRED
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
              });
              const commonWGSL = (
                /* wgsl */
                `
            struct Params {
              nx: u32, ny: u32, nz: u32, step: i32,
              sx: u32, sxy: u32, _pad: u32, voxelSize: f32
            };
            @group(0) @binding(0) var<uniform> P : Params;
            
            fn idx3D(x:u32,y:u32,z:u32) -> u32 { return x + y*P.nx + z*P.nx*P.ny; }
            const SENTINEL:u32 = 0xFFFFFFFFu;
            `
              );
              const clearWGSL = (
                /* wgsl */
                `
            ${commonWGSL}
            @group(0) @binding(1) var<storage, read_write> outSeeds : array<u32>;
            @compute @workgroup_size(8,8,4)
            fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              if (gid.x>=P.nx || gid.y>=P.ny || gid.z>=P.nz) { return; }
              let i = idx3D(gid.x,gid.y,gid.z) * 4u;
              outSeeds[i+0]=SENTINEL; outSeeds[i+1]=SENTINEL; outSeeds[i+2]=SENTINEL; outSeeds[i+3]=0u;
            }
            `
              );
              const stampWGSL = (
                /* wgsl */
                `
            ${commonWGSL}
            struct SeedRec { x:u32, y:u32, z:u32, w:u32 };
            @group(0) @binding(1) var<storage, read_write> grid : array<u32>;
            @group(0) @binding(2) var<storage, read> seeds : array<SeedRec>;
            @compute @workgroup_size(256)
            fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              let i = gid.x; if (i >= arrayLength(&seeds)) { return; }
              let s = seeds[i]; if (s.x>=P.nx || s.y>=P.ny || s.z>=P.nz) { return; }
              let base = idx3D(s.x,s.y,s.z) * 4u;
              grid[base+0]=s.x; grid[base+1]=s.y; grid[base+2]=s.z; grid[base+3]=0u;
            }
            `
              );
              const jfaWGSL = (
                /* wgsl */
                `
            ${commonWGSL}
            @group(0) @binding(1) var<storage, read> inGrid  : array<u32>;
            @group(0) @binding(2) var<storage, read_write> outGrid : array<u32>;
            
            fn isValid(x:u32)->bool { return x != SENTINEL; }
            
            fn read4(arr: ptr<storage, array<u32>>, base:u32) -> vec4<u32> {
              return vec4<u32>((*arr)[base+0], (*arr)[base+1], (*arr)[base+2], (*arr)[base+3]);
            }
            
            fn dist2(x:u32,y:u32,z:u32, s:vec4<u32>) -> f32 {
              let dx = f32(i32(x) - i32(s.x));
              let dy = f32(i32(y) - i32(s.y));
              let dz = f32(i32(z) - i32(s.z));
              return dx*dx + dy*dy + dz*dz;
            }
            
            @compute @workgroup_size(8,8,4)
            fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              if (gid.x>=P.nx || gid.y>=P.ny || gid.z>=P.nz) { return; }
              let base = idx3D(gid.x,gid.y,gid.z) * 4u;
              var best = read4(&inGrid, base);
              var bestD = select(1e30, dist2(gid.x,gid.y,gid.z,best), isValid(best.x));
            
              let s = P.step;
              for (var dz:i32=-1; dz<=1; dz++) {
                for (var dy:i32=-1; dy<=1; dy++) {
                  for (var dx:i32=-1; dx<=1; dx++) {
                    if (dx==0 && dy==0 && dz==0) { continue; }
                    let nx = i32(gid.x) + dx*s;
                    let ny = i32(gid.y) + dy*s;
                    let nz = i32(gid.z) + dz*s;
                    if (nx<0 || ny<0 || nz<0) { continue; }
                    if (nx>=i32(P.nx) || ny>=i32(P.ny) || nz>=i32(P.nz)) { continue; }
                    let nbase = idx3D(u32(nx),u32(ny),u32(nz)) * 4u;
                    let cand = read4(&inGrid, nbase);
                    if (!isValid(cand.x)) { continue; }
                    let d = dist2(gid.x,gid.y,gid.z,cand);
                    if (d < bestD) { bestD = d; best = cand; }
                  }
                }
              }
              outGrid[base+0]=best.x; outGrid[base+1]=best.y; outGrid[base+2]=best.z; outGrid[base+3]=best.w;
            }
            `
              );
              const finalizeWGSL = (
                /* wgsl */
                `
            ${commonWGSL}
            @group(0) @binding(1) var<storage, read> inGrid : array<u32>;
            @group(0) @binding(2) var outTex : texture_storage_3d<r32float, write>;
            
            fn read4(arr: ptr<storage, array<u32>>, base:u32) -> vec4<u32> {
                return vec4<u32>((*arr)[base+0], (*arr)[base+1], (*arr)[base+2], (*arr)[base+3]);
            }
            const INF:f32 = 3.4028235e28;
            
            @compute @workgroup_size(8,8,4)
            fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              if (gid.x>=P.nx || gid.y>=P.ny || gid.z>=P.nz) { return; }
              let base = idx3D(gid.x,gid.y,gid.z) * 4u;
              let seed = read4(&inGrid, base);
              var dist = INF;
              if (seed.x != 0xFFFFFFFFu) {
                let dx = f32(i32(gid.x) - i32(seed.x));
                let dy = f32(i32(gid.y) - i32(seed.y));
                let dz = f32(i32(gid.z) - i32(seed.z));
                dist = sqrt(dx*dx+dy*dy+dz*dz) * P.voxelSize; // unsigned distance in meters
              }
              textureStore(outTex, vec3<i32>(i32(gid.x),i32(gid.y),i32(gid.z)), vec4<f32>(dist,0.0,0.0,1.0));
            }
            `
              );
              const clearPipeline = device2.createComputePipeline({ layout: "auto", compute: { module: device2.createShaderModule({ code: clearWGSL }), entryPoint: "main" } });
              const stampPipeline = device2.createComputePipeline({ layout: "auto", compute: { module: device2.createShaderModule({ code: stampWGSL }), entryPoint: "main" } });
              const jfaPipeline = device2.createComputePipeline({ layout: "auto", compute: { module: device2.createShaderModule({ code: jfaWGSL }), entryPoint: "main" } });
              const finPipeline = device2.createComputePipeline({ layout: "auto", compute: { module: device2.createShaderModule({ code: finalizeWGSL }), entryPoint: "main" } });
              const writeParams = (step2) => {
                const tmp = new ArrayBuffer(8 * 4);
                const u32 = new Uint32Array(tmp);
                const i32 = new Int32Array(tmp);
                const f32 = new Float32Array(tmp);
                u32[0] = nx;
                u32[1] = ny;
                u32[2] = nz;
                i32[3] = step2 | 0;
                u32[4] = 1;
                u32[5] = nx * ny;
                u32[6] = 0;
                f32[7] = voxelSize;
                device2.queue.writeBuffer(params, 0, tmp);
              };
              const wg3 = (x, y, z) => ({ x: Math.ceil(x / 8), y: Math.ceil(y / 8), z: Math.ceil(z / 4) });
              writeParams(1);
              {
                const bg = device2.createBindGroup({
                  layout: clearPipeline.getBindGroupLayout(0),
                  entries: [
                    { binding: 0, resource: { buffer: params } },
                    { binding: 1, resource: { buffer: gridA } }
                  ]
                });
                const enc = device2.createCommandEncoder();
                const pass = enc.beginComputePass();
                pass.setPipeline(clearPipeline);
                pass.setBindGroup(0, bg);
                const w = wg3(nx, ny, nz);
                pass.dispatchWorkgroups(w.x, w.y, w.z);
                pass.end();
                device2.queue.submit([enc.finish()]);
              }
              writeParams(1);
              {
                const bg = device2.createBindGroup({
                  layout: stampPipeline.getBindGroupLayout(0),
                  entries: [
                    { binding: 0, resource: { buffer: params } },
                    { binding: 1, resource: { buffer: gridA } },
                    { binding: 2, resource: { buffer: seedList } }
                  ]
                });
                const enc = device2.createCommandEncoder();
                const pass = enc.beginComputePass();
                pass.setPipeline(stampPipeline);
                pass.setBindGroup(0, bg);
                pass.dispatchWorkgroups(Math.ceil((seeds2.length || 1) / 256));
                pass.end();
                device2.queue.submit([enc.finish()]);
              }
              let maxDim = Math.max(nx, ny, nz);
              let step = 1;
              while (step << 1 <= maxDim) step <<= 1;
              let pingIn = gridA, pingOut = gridB;
              while (step >= 1) {
                writeParams(step);
                const bg = device2.createBindGroup({
                  layout: jfaPipeline.getBindGroupLayout(0),
                  entries: [
                    { binding: 0, resource: { buffer: params } },
                    { binding: 1, resource: { buffer: pingIn } },
                    { binding: 2, resource: { buffer: pingOut } }
                  ]
                });
                const enc = device2.createCommandEncoder();
                const pass = enc.beginComputePass();
                pass.setPipeline(jfaPipeline);
                pass.setBindGroup(0, bg);
                const w = wg3(nx, ny, nz);
                pass.dispatchWorkgroups(w.x, w.y, w.z);
                pass.end();
                device2.queue.submit([enc.finish()]);
                const t = pingIn;
                pingIn = pingOut;
                pingOut = t;
                step >>= 1;
              }
              writeParams(1);
              {
                const bg = device2.createBindGroup({
                  layout: finPipeline.getBindGroupLayout(0),
                  entries: [
                    { binding: 0, resource: { buffer: params } },
                    { binding: 1, resource: { buffer: pingIn } },
                    { binding: 2, resource: sdfTex2.createView({ dimension: "3d" }) }
                  ]
                });
                const enc = device2.createCommandEncoder();
                const pass = enc.beginComputePass();
                pass.setPipeline(finPipeline);
                pass.setBindGroup(0, bg);
                const w = wg3(nx, ny, nz);
                pass.dispatchWorkgroups(w.x, w.y, w.z);
                pass.end();
                device2.queue.submit([enc.finish()]);
              }
              return sdfTex2;
            }
            function createSlicePipelines(device2, dims2) {
              const { nx, ny, nz } = dims2;
              const sliceTex2 = device2.createTexture({
                size: { width: nx, height: ny },
                format: "rgba8unorm",
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
              });
              const sliceParams2 = device2.createBuffer({ size: 6 * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
              const writeSliceParams2 = (z, minV, maxV) => {
                const tmp = new ArrayBuffer(24);
                const u32 = new Uint32Array(tmp);
                const f32 = new Float32Array(tmp);
                u32[0] = nx;
                u32[1] = ny;
                u32[2] = nz;
                u32[3] = z | 0;
                f32[4] = minV;
                f32[5] = maxV;
                device2.queue.writeBuffer(sliceParams2, 0, tmp);
              };
              const sliceWGSL = (
                /* wgsl */
                `
            struct P { nx:u32, ny:u32, nz:u32, z:u32, minV:f32, maxV:f32 };
            @group(0) @binding(0) var<uniform> U : P;
            @group(0) @binding(1) var sdfTex : texture_3d<f32>;
            @group(0) @binding(2) var out2D  : texture_storage_2d<rgba8unorm, write>;
            
            @compute @workgroup_size(8,8)
            fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              if (gid.x>=U.nx || gid.y>=U.ny) { return; }
              let v = textureLoad(sdfTex, vec3<i32>(i32(gid.x), i32(gid.y), i32(U.z)), 0).x;
              var t = (v - U.minV) / (U.maxV - U.minV);
              t = clamp(t, 0.0, 1.0);
              textureStore(out2D, vec2<i32>(i32(gid.x), i32(gid.y)), vec4<f32>(t,t,t,1.0));
            }
            `
              );
              const slicePipeline2 = device2.createComputePipeline({ layout: "auto", compute: { module: device2.createShaderModule({ code: sliceWGSL }), entryPoint: "main" } });
              return { sliceTex: sliceTex2, sliceParams: sliceParams2, writeSliceParams: writeSliceParams2, slicePipeline: slicePipeline2 };
            }
            function createBlitPipeline(device2, format) {
              const vs = (
                /* wgsl */
                `
            struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
            @vertex
            fn main(@builtin(vertex_index) vi: u32) -> VSOut {
              var p = array<vec2<f32>,3>(
                vec2<f32>(-1.0,-3.0), vec2<f32>(3.0,1.0), vec2<f32>(-1.0,1.0)
              );
              var uv = array<vec2<f32>,3>(
                vec2<f32>(0.0,2.0), vec2<f32>(2.0,0.0), vec2<f32>(0.0,0.0)
              );
              var o:VSOut; o.pos = vec4<f32>(p[vi], 0.0, 1.0); o.uv = uv[vi]; return o;
            }
            `
              );
              const fs = (
                /* wgsl */
                `
            @group(0) @binding(0) var samp: sampler; // filtering OK here
            @group(0) @binding(1) var img : texture_2d<f32>;
            @fragment
            fn main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
              return textureSample(img, samp, uv);
            }
            `
              );
              const pipeline = device2.createRenderPipeline({
                layout: "auto",
                vertex: { module: device2.createShaderModule({ code: vs }), entryPoint: "main" },
                fragment: { module: device2.createShaderModule({ code: fs }), entryPoint: "main", targets: [{ format }] },
                primitive: { topology: "triangle-list" }
              });
              const sampler2 = device2.createSampler({ magFilter: "nearest", minFilter: "nearest" });
              return { pipeline, sampler: sampler2 };
            }
            function makeCubeSeeds(dims2) {
              const { nx, ny, nz } = dims2;
              const seeds2 = (
                /** @type {Seed[]} */
                []
              );
              const cx0 = Math.floor(nx * 0.35), cx1 = Math.floor(nx * 0.75);
              const cy0 = Math.floor(ny * 0.35), cy1 = Math.floor(ny * 0.75);
              const cz0 = Math.floor(nz * 0.35), cz1 = Math.floor(nz * 0.75);
              for (let z = cz0; z <= cz1; z++)
                for (let y = cy0; y <= cy1; y++)
                  for (let x = cx0; x <= cx1; x++) {
                    const onSurf = x === cx0 || x === cx1 || y === cy0 || y === cy1 || z === cz0 || z === cz1;
                    if (onSurf) seeds2.push({ x, y, z });
                  }
              return seeds2;
            }
            const dims = (
              /** @type {GridDims} */
              { nx: 128, ny: 128, nz: 128, voxelSize: 5e-3 }
            );
            const seeds = makeCubeSeeds(dims);
            console.log("Seeds:", seeds.length);
            const sdfTex = await buildSDF(device, seeds, dims);
            const { sliceTex, sliceParams, writeSliceParams, slicePipeline } = createSlicePipelines(device, dims);
            const { pipeline: blitPipe, sampler } = createBlitPipeline(device, canvasFormat);
            const zMax = dims.nz - 1;
            zSlider.max = String(zMax);
            function computeSliceAndRender(z) {
              writeSliceParams(z, visMin, visMax);
              const enc = device.createCommandEncoder();
              const cpass = enc.beginComputePass();
              cpass.setPipeline(slicePipeline);
              const bg0 = device.createBindGroup({
                layout: slicePipeline.getBindGroupLayout(0),
                entries: [
                  { binding: 0, resource: { buffer: sliceParams } },
                  { binding: 1, resource: sdfTex.createView() },
                  { binding: 2, resource: sliceTex.createView() }
                ]
              });
              cpass.setBindGroup(0, bg0);
              cpass.dispatchWorkgroups(Math.ceil(dims.nx / 8), Math.ceil(dims.ny / 8));
              cpass.end();
              const view = context.getCurrentTexture().createView();
              const rpass = enc.beginRenderPass({ colorAttachments: [{ view, loadOp: "clear", storeOp: "store", clearValue: { r: 0, g: 0, b: 0, a: 1 } }] });
              rpass.setPipeline(blitPipe);
              const bg1 = device.createBindGroup({
                layout: blitPipe.getBindGroupLayout(0),
                entries: [
                  { binding: 0, resource: sampler },
                  { binding: 1, resource: sliceTex.createView() }
                ]
              });
              rpass.setBindGroup(0, bg1);
              rpass.draw(3, 1, 0, 0);
              rpass.end();
              device.queue.submit([enc.finish()]);
            }
            computeSliceAndRender(Number(zSlider.value | 0));
            zSlider.addEventListener("input", (e) => {
              const z = Number(zSlider.value | 0);
              computeSliceAndRender(z);
            });
            window.addEventListener("wheel", (e) => {
              if (e.shiftKey) {
                visMax = Math.max(0.01, visMax * (e.deltaY > 0 ? 1.1 : 0.9));
                updateWinText();
                computeSliceAndRender(Number(zSlider.value | 0));
              }
            }, { passive: true });
            console.log("Ready. This is an *unsigned* SDF. To add a sign, compute an inside/outside mask (e.g., flood-fill on a solid voxel mask) and multiply the unsigned distance by (-1) for inside voxels.");
            
            </script>
        </body>
    </html>