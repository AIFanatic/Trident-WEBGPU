
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
            <meta name="mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-capable" content="yes">
            
            <style>
                html, body {
                    margin: 0;
                    overflow: hidden;
                    width: 100%;
                    height: 100%;
                }
            </style>
        </head>
        <body>
            <script type="importmap">
                {
                    "imports": {
                        "@trident/core": "../trident-core.js",
                        "@trident/plugins/": "../plugins/"
                    }
                }
            </script>
            <script type="module">
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                            import { Components, Mathf, GameObject } from '@trident/core';
            import { PhysicsRapier } from '@trident/plugins/PhysicsRapier/PhysicsRapier.js';
            
            class FakeGI extends Components.Component {
              useRaycasting = false;
              secondaryBounce = false;
              useIndirectShadows = false;
              automaticWeights = false;
              distanceScale = 1;
              avgRefl = 0.4;
              avgSecondaryDistance = 1;
              smooth = true;
              lights = [];
              reflectance = [];
              weights = [];
              blockers = [];
              isDirectional = false;
              isSpot = false;
              oldVplPos = new Mathf.Vector3();
              oldVplNormal = new Mathf.Vector3();
              source;
              dynamicVplGo;
              dynamicVpl;
              dynamicVplSecondaryGo;
              dynamicVplSecondary;
              static k = 0;
              static dMin = 1e5;
              Start() {
                this.source = this.gameObject.GetComponent(Components.Light);
                if (!this.source) throw new Error("FakeGI requires a Light on the same GameObject.");
                this.isDirectional = this.source instanceof Components.DirectionalLight;
                this.isSpot = this.source instanceof Components.SpotLight;
                if (!this.isSpot && this.useRaycasting) {
                  this.useRaycasting = false;
                  console.warn("FakeGI: raycasting is only supported for spot lights. Disabled.");
                }
                this.getAllVPLs();
                this.getAllBlockers();
                if (this.useRaycasting) {
                  this.dynamicVplGo = new GameObject(this.gameObject.scene);
                  this.dynamicVpl = this.dynamicVplGo.AddComponent(Components.SpotLight);
                  this.dynamicVpl.angle = 155 * Mathf.Deg2Rad * 0.5;
                  this.dynamicVplGo.name = "DynamicVPL";
                  this.dynamicVpl.enabled = false;
                  this.oldVplNormal = FakeGI.getForward(this.source.gameObject);
                  this.oldVplPos.set(0, 0, 0);
                  this.dynamicVpl.castShadows = this.useIndirectShadows;
                }
                if (this.secondaryBounce) {
                  this.dynamicVplSecondaryGo = new GameObject(this.gameObject.scene);
                  this.dynamicVplSecondary = this.dynamicVplSecondaryGo.AddComponent(Components.SpotLight);
                  this.dynamicVplSecondary.angle = 160 * Mathf.Deg2Rad * 0.5;
                  this.dynamicVplSecondaryGo.name = "DynamicVPL-secondary";
                  this.dynamicVplSecondary.range = this.source?.range ?? 10;
                  this.dynamicVplSecondary.enabled = false;
                }
              }
              Update() {
                if (this.automaticWeights) this.updateWeightsAmortized();
                const sourceDir = FakeGI.getForward(this.source.gameObject);
                const sourcePos = this.source.gameObject.transform.position.clone();
                const sourceIntensity = this.source.intensity;
                const sourceColor = this.source.color.clone();
                if (this.useRaycasting) {
                  if (!PhysicsRapier.hasLoaded) return;
                  const maxDistance = this.source?.range ?? 100;
                  const hit = FakeGI.raycast(sourcePos, sourceDir, maxDistance);
                  if (!hit) {
                    this.dynamicVpl.enabled = false;
                    return;
                  }
                  const dist = hit.timeOfImpact / this.distanceScale;
                  let intensity = sourceIntensity / (0.1 + dist * dist);
                  if (this.oldVplPos.length() === 0) this.oldVplPos.copy(hit.point);
                  const dvplPos = this.smooth ? hit.point.clone().add(this.oldVplPos).mul(0.5) : hit.point.clone();
                  this.oldVplPos.copy(dvplPos);
                  const dvplDirPos = dvplPos.clone().add(sourceDir.clone().mul(0.6));
                  this.dynamicVplGo.transform.position.copy(dvplDirPos);
                  this.dynamicVpl.color.set(0, 0, 0, 1);
                  let wTotal = 0;
                  let areaFactor = 0;
                  const vplNormal = new Mathf.Vector3(0, 0, 0);
                  for (let i = 0; i < this.lights.length; i++) {
                    const lightPos = this.lights[i].gameObject.transform.position;
                    const toVpl = lightPos.clone().sub(dvplPos);
                    const vplDist = toVpl.length() / this.distanceScale;
                    const w = 1 / (5e-3 + vplDist * vplDist);
                    const c = this.lights[i].color;
                    this.dynamicVpl.color.set(
                      this.dynamicVpl.color.r + w * c.r,
                      this.dynamicVpl.color.g + w * c.g,
                      this.dynamicVpl.color.b + w * c.b,
                      1
                    );
                    areaFactor += this.weights[i] * w;
                    if (this.lights[i] instanceof Components.SpotLight) {
                      vplNormal.add(FakeGI.getForward(this.lights[i].gameObject).mul(w));
                    } else {
                      vplNormal.add(sourceDir.clone().mul(-w));
                    }
                    wTotal += w;
                  }
                  if (wTotal > 0) {
                    this.dynamicVpl.color.set(
                      this.dynamicVpl.color.r * sourceColor.r / wTotal,
                      this.dynamicVpl.color.g * sourceColor.g / wTotal,
                      this.dynamicVpl.color.b * sourceColor.b / wTotal,
                      1
                    );
                  }
                  vplNormal.normalize();
                  const smoothNormal = this.smooth ? this.oldVplNormal.clone().add(vplNormal).mul(0.5) : vplNormal.clone();
                  this.oldVplNormal.copy(smoothNormal);
                  this.dynamicVplGo.transform.LookAtV1(dvplPos.clone().add(smoothNormal));
                  this.dynamicVpl.enabled = true;
                  const cosThetaI = Math.max(smoothNormal.dot(sourceDir.clone().mul(-1)), 0);
                  intensity *= cosThetaI * (areaFactor / Math.max(wTotal, 1e-4));
                  this.dynamicVpl.intensity = intensity;
                  if (this.secondaryBounce && this.dynamicVplSecondary) {
                    const primDist = hit.timeOfImpact;
                    const secDist = (0.5 * primDist + hit.timeOfImpact) / this.distanceScale;
                    const secInt = this.avgRefl * intensity / (1 + secDist * secDist);
                    this.dynamicVplSecondary.color.copy(this.dynamicVpl.color);
                    this.dynamicVplSecondaryGo.transform.LookAtV1(dvplPos.clone().sub(smoothNormal));
                    const secPos2 = dvplPos.clone().sub(sourceDir.clone().mul(hit.timeOfImpact * 1.5));
                    this.dynamicVplSecondaryGo.transform.position.copy(secPos2);
                    this.dynamicVplSecondary.enabled = true;
                    this.dynamicVplSecondary.intensity = secInt;
                  }
                  return;
                }
                let secIntensity = 0;
                const secPos = new Mathf.Vector3();
                const secDir = new Mathf.Vector3();
                const secColor = new Mathf.Color();
                let secWeight = 0;
                for (let i = 0; i < this.lights.length; i++) {
                  const lightPos = this.lights[i].gameObject.transform.position;
                  const toVpl = this.isDirectional ? sourceDir.clone() : lightPos.clone().sub(sourcePos);
                  const toVplNorm = toVpl.clone().normalize();
                  let dot = toVplNorm.dot(sourceDir);
                  let intensity = sourceIntensity * this.weights[i];
                  if (this.isSpot && this.source instanceof Components.SpotLight) {
                    const angleCos = Math.cos(this.source.angle * 2);
                    intensity *= Math.max(0, (dot - angleCos) / (1 - angleCos));
                  }
                  if (!this.isDirectional) {
                    const dist = toVpl.length() / this.distanceScale;
                    intensity *= 1 / (0.1 + dist * dist);
                  }
                  if (this.isSpot || this.isDirectional) {
                    const vplNormal = FakeGI.getForward(this.lights[i].gameObject);
                    dot = Math.max(0, toVplNorm.dot(vplNormal.clone().mul(-1)));
                    intensity *= dot;
                  }
                  if (this.blockers.length > 0) {
                    const endpoint = this.isDirectional ? lightPos.clone().sub(toVplNorm.clone().mul(100)) : sourcePos;
                    for (let j = 0; j < this.blockers.length; j++) {
                      const blockerPos = this.blockers[j].gameObject.transform.position;
                      const distToBlocker = FakeGI.pointToSegmentDistanceSquared(blockerPos, endpoint, lightPos);
                      const range = this.blockers[j]?.range ?? this.blockers[j]?.range ?? 1;
                      const filter = Math.min(1, distToBlocker / (1e-4 + range * range));
                      intensity *= filter;
                    }
                  }
                  if (intensity <= 0.01) {
                    this.lights[i].enabled = false;
                  } else {
                    this.lights[i].enabled = true;
                    this.lights[i].intensity = intensity;
                    const rc = this.reflectance[i];
                    this.lights[i].color.set(
                      rc.r * sourceColor.r,
                      rc.g * sourceColor.g,
                      rc.b * sourceColor.b,
                      1
                    );
                  }
                  if (this.secondaryBounce) {
                    const w = intensity / Math.max(sourceIntensity, 1e-4);
                    secIntensity += w * this.avgRefl * intensity;
                    secColor.set(
                      secColor.r + w * this.lights[i].color.r,
                      secColor.g + w * this.lights[i].color.g,
                      secColor.b + w * this.lights[i].color.b,
                      1
                    );
                    secPos.add(lightPos.clone().mul(w));
                    secDir.sub(FakeGI.getForward(this.lights[i].gameObject).mul(w));
                    secWeight += w + 1e-3;
                  }
                }
                if (this.secondaryBounce && this.dynamicVplSecondary) {
                  this.dynamicVplSecondaryGo.transform.position.copy(secPos.div(secWeight).sub(sourceDir.clone().mul(this.avgSecondaryDistance)));
                  this.dynamicVplSecondaryGo.transform.LookAtV1(this.dynamicVplSecondaryGo.transform.position.clone().add(secDir.normalize()));
                  this.dynamicVplSecondary.intensity = secIntensity / (secWeight * this.avgSecondaryDistance * this.avgSecondaryDistance);
                  this.dynamicVplSecondary.color.set(secColor.r / secWeight, secColor.g / secWeight, secColor.b / secWeight, 1);
                  this.dynamicVplSecondary.enabled = true;
                }
              }
              updateWeightsAmortized() {
                if (this.lights.length === 1) {
                  this.weights[0] = 1;
                  return;
                }
                const current = FakeGI.k % this.lights.length;
                const other = Math.floor(FakeGI.k / this.lights.length);
                if (other === 0) FakeGI.dMin = 1e5;
                if (current === other) {
                  FakeGI.k = (FakeGI.k + 1) % (this.lights.length * this.lights.length);
                  return;
                }
                const v = this.lights[current].gameObject.transform.position.clone().sub(this.lights[other].gameObject.transform.position);
                const d = v.dot(v);
                if (d < FakeGI.dMin) FakeGI.dMin = d;
                if (other === this.lights.length - 1) {
                  this.weights[current] = FakeGI.dMin;
                }
                FakeGI.k = (FakeGI.k + 1) % (this.lights.length * this.lights.length);
              }
              getAllBlockers() {
                const scene = this.gameObject.scene;
                for (const go of scene.GetGameObjects()) {
                  if (go.name !== "BLOCKERS") continue;
                  for (const child of go.transform.children) {
                    const l = child.gameObject.GetComponent(Components.Light);
                    if (!l) continue;
                    l.enabled = false;
                    this.blockers.push(l);
                  }
                }
              }
              getAllVPLs() {
                const scene = this.gameObject.scene;
                for (const go of scene.GetGameObjects()) {
                  if (go.name !== "VPLs" || !go.enabled) continue;
                  for (const child of go.transform.children) {
                    const l = child.gameObject.GetComponent(Components.Light);
                    if (!l) continue;
                    if (l instanceof Components.SpotLight && this.source instanceof Components.SpotLight) {
                      l.angle = 170 * Mathf.Deg2Rad * 0.5;
                      l.range = this.source.range;
                    }
                    this.weights.push(l.intensity);
                    l.intensity = 0;
                    l.enabled = false;
                    this.lights.push(l);
                    this.reflectance.push(l.color.clone());
                    l.castShadows = this.useIndirectShadows;
                  }
                }
              }
              static pointToSegmentDistanceSquared(q, x0, x1) {
                const dir = x1.clone().sub(x0);
                const dirLen = dir.length();
                if (dirLen === 0) return q.distanceToSquared(x0);
                const dirNorm = dir.clone().div(dirLen);
                const lq = dirNorm.dot(q.clone().sub(x0));
                if (lq < 0) return q.distanceToSquared(x0);
                if (lq > dirLen) return q.distanceToSquared(x1);
                const o = dirNorm.mul(lq).add(x0).sub(q);
                return o.dot(o);
              }
              static getForward(go) {
                return new Mathf.Vector3(0, 0, 1).applyQuaternion(go.transform.rotation).normalize();
              }
              static raycast(origin, direction, maxDistance) {
                const dir = direction.clone().normalize();
                const ray = new PhysicsRapier.Physics.Ray(origin, dir);
                const hit = PhysicsRapier.PhysicsWorld.castRayAndGetNormal(ray, maxDistance, true);
                if (!hit) return null;
                const point = origin.clone().add(dir.clone().mul(hit.timeOfImpact));
                return { timeOfImpact: hit.timeOfImpact, normal: hit.normal, point };
              }
            }
            
            export { FakeGI };
            
            </script>
        </body>
    </html>