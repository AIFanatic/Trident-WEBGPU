
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
            <meta name="mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-capable" content="yes">
            
            <style>
                html, body {
                    margin: 0;
                    overflow: hidden;
                    height: 100%;
                    width: 100%;
                }
            </style>
        </head>
        <body>
            <script type="importmap">
                {
                    "imports": {
                        "@trident/core": "../trident-core.js",
                        "@trident/plugins/": "../plugins/"
                    }
                }
            </script>
            <script type="module">
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                            import { GPU, Scene, GameObject, Components, Mathf, Geometry, PBRMaterial, Input, KeyCodes, MouseCodes } from '@trident/core';
            import { PhysicsRapier } from '@trident/plugins/PhysicsRapier/PhysicsRapier.js';
            import { TerrainCollider } from '@trident/plugins/PhysicsRapier/colliders/TerrainCollider.js';
            import { CapsuleCollider } from '@trident/plugins/PhysicsRapier/colliders/CapsuleCollider.js';
            import { BoxCollider } from '@trident/plugins/PhysicsRapier/colliders/BoxCollider.js';
            import { ThirdPersonController } from '@trident/plugins/PhysicsRapier/ThirdPersonController.js';
            import { RigidBody, RigidbodyConstraints } from '@trident/plugins/PhysicsRapier/RigidBody.js';
            import { Debugger } from '@trident/plugins/Debugger.js';
            import { HDRParser } from '@trident/plugins/HDRParser.js';
            import { GLTFLoader } from '@trident/plugins/GLTF/GLTFLoader.js';
            import { UIFolder, UIVecStat } from '@trident/plugins/ui/UIStats.js';
            import { OrbitControls } from '@trident/plugins/OrbitControls.js';
            import { Terrain } from '@trident/plugins/Terrain/Terrain.js';
            import { Sky } from '@trident/plugins/Sky.js';
            
            async function Application(canvas) {
              const renderer = GPU.Renderer.Create(canvas, "webgpu");
              const scene = new Scene(renderer);
              const mainCameraGameObject = new GameObject(scene);
              mainCameraGameObject.transform.position.set(0, 0, 5);
              mainCameraGameObject.name = "MainCamera";
              const camera = mainCameraGameObject.AddComponent(Components.Camera);
              camera.SetPerspective(70, canvas.width / canvas.height, 0.2, 1e4);
              mainCameraGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const lightGameObject = new GameObject(scene);
              lightGameObject.transform.position.set(4, 4, 4).mul(10);
              lightGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const light = lightGameObject.AddComponent(Components.DirectionalLight);
              light.intensity = 1e-5;
              const physicsWorld = new GameObject(scene);
              const physicsComponent = physicsWorld.AddComponent(PhysicsRapier);
              await physicsComponent.Load();
              const terrainGameObject = new GameObject(scene);
              const terrain = terrainGameObject.AddComponent(Terrain);
              terrain.width = 1e3;
              terrain.length = 1e3;
              terrain.height = 200;
              await terrain.HeightmapFromPNG("/extra/test-assets/terrain/heightmaps/elevation_1024x1024.png", true, 0.25);
              async function LoadTerrainTextures(urls) {
                let textures = [];
                for (const url of urls) {
                  const texture = await GPU.Texture.Load(url);
                  texture.GenerateMips();
                  textures.push(texture);
                }
                return textures;
              }
              async function LoadTexture(url) {
                const texture = await GPU.Texture.Load(url);
                texture.GenerateMips();
                return texture;
              }
              const biomes_splat_map = await GPU.Texture.Load("/extra/test-assets/terrain/heightmaps/biomeids_1024x1024.png");
              biomes_splat_map.GenerateMips();
              terrain.material.layerTexture = biomes_splat_map;
              terrain.material.splatMapTextures = await LoadTerrainTextures([
                "/extra/test-assets/terrain/heightmaps/splatmap_1024x1024.png"
                //"/extra/test-assets/terrain/heightmaps/splat0_island_1024x1024.png",
              ]);
              const basePath = "/extra/test-assets/terrain/Terrain Textures";
              let transform = new Float32Array([10, 10, 0, 0]);
              const mat = "Grass 01";
              terrain.material.layers = [
                { name: "TropicalForest", transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `Water`, transform, albedoMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_BaseColor.png`), normalMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_Normal.png`), armMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: await LoadTexture(basePath + `/${mat}/${mat}_BaseColor.png`), normalMap: await LoadTexture(basePath + `/${mat}/${mat}_Normal.png`), armMap: await LoadTexture(basePath + `/${mat}/${mat}_MaskMap.png`) }
              ];
              const heightsSize = Math.sqrt(terrain.heights.length);
              console.log(heightsSize);
              terrainGameObject.transform.position.z -= terrain.width * 0.5;
              terrainGameObject.transform.position.x -= terrain.length * 0.5;
              const terrainCollider = terrainGameObject.AddComponent(TerrainCollider);
              terrainCollider.SetTerrainData(heightsSize - 1, heightsSize - 1, terrain.heights, terrainGameObject.transform.scale);
              {
                {
                  const boxGO2 = new GameObject(scene);
                  boxGO2.transform.position.y = 200;
                  boxGO2.transform.scale.set(1, 1, 1);
                  const boxMesh2 = boxGO2.AddComponent(Components.Mesh);
                  boxMesh2.geometry = Geometry.Cube();
                  boxMesh2.material = new PBRMaterial({ albedoColor: new Mathf.Color(1, 0, 0, 1), roughness: 0.3 });
                  boxGO2.AddComponent(BoxCollider);
                  const rigidbody = boxGO2.AddComponent(RigidBody);
                  rigidbody.Create("fixed");
                }
              }
              const skyAtmosphere = new Sky();
              await skyAtmosphere.init();
              await skyAtmosphere.preFrame();
              await skyAtmosphere.execute();
              const sky = await HDRParser.ToCubemap(skyAtmosphere.output);
              const skyIrradiance = await HDRParser.GetIrradianceMap(sky);
              const prefilterMap = await HDRParser.GetPrefilterMap(sky);
              const brdfLUT = await HDRParser.GetBRDFLUT(1);
              scene.renderPipeline.skybox = sky;
              scene.renderPipeline.skyboxIrradiance = skyIrradiance;
              scene.renderPipeline.skyboxPrefilter = prefilterMap;
              scene.renderPipeline.skyboxBRDFLUT = brdfLUT;
              function traverse(gameObjects, fn) {
                for (const gameObject of gameObjects) {
                  fn(gameObject);
                  for (const child of gameObject.transform.children) {
                    traverse([child.gameObject], fn);
                  }
                }
              }
              const sceneGameObject = await GLTFLoader.loadAsGameObjects(scene, "./assets/models/Shadow.glb");
              let animator = void 0;
              traverse([sceneGameObject], (gameObject) => {
                const _animator = gameObject.GetComponent(Components.Animator);
                if (_animator) animator = _animator;
              });
              if (!animator) throw Error("Could not find an animator component");
              function GetClipIndexByName(animator2, name, partialMatch = true) {
                for (let i = 0; i < animator2.clips.length; i++) {
                  animator2.clips[i];
                  if (partialMatch && animator2.clips[i].name.toLowerCase().includes(name.toLocaleLowerCase())) return i;
                  else if (animator2.clips[i].name === name) return i;
                }
                return -1;
              }
              const playerGameObject = new GameObject(scene);
              playerGameObject.transform.position.set(0, 100, 0);
              playerGameObject.AddComponent(CapsuleCollider);
              const playerRigidbody = playerGameObject.AddComponent(RigidBody);
              playerRigidbody.Create("dynamic");
              playerRigidbody.constraints = RigidbodyConstraints.FreezeRotation;
              const thirdPersonController = playerGameObject.AddComponent(ThirdPersonController);
              thirdPersonController._controller = playerRigidbody;
              thirdPersonController._model = sceneGameObject;
              thirdPersonController._mainCamera = camera.gameObject;
              thirdPersonController._animator = animator;
              thirdPersonController._animationIDS = { idle: GetClipIndexByName(animator, "Rig|Rig|Idle_Loop", false), walk: GetClipIndexByName(animator, "Rig|Rig|Walk_Loop", false), sprint: GetClipIndexByName(animator, "sprint"), jump: GetClipIndexByName(animator, "Jump_Start"), fall: GetClipIndexByName(animator, "fall") };
              thirdPersonController.animationSpeedRatio = 0.8;
              thirdPersonController.boostMultiplier = 20;
              const boxGO = new GameObject(scene);
              boxGO.transform.position.y = 1.5;
              boxGO.transform.position.x = 2;
              const boxMesh = boxGO.AddComponent(Components.Mesh);
              boxMesh.geometry = Geometry.Cube();
              boxMesh.material = new PBRMaterial({ albedoColor: new Mathf.Color(0, 1, 0, 1) });
              class NatureSpawner extends Components.Component {
                spawnAnimationID = -1;
                moveAnimationID = -1;
                animator;
                thirdPersonController;
                rigidBody;
                spawnPrefab;
                isSpelling = false;
                Start() {
                  if (!this.animator) throw Error("No animator");
                  if (!this.thirdPersonController) throw Error("No thirdPersonController");
                  if (!this.rigidBody) throw Error("No rigidbody");
                  if (!this.spawnPrefab) throw Error("No spawnPrefab");
                }
                Update() {
                  if (!this.isSpelling) {
                    if (Input.GetKey(KeyCodes.Q)) {
                      this.animator.CrossFadeTo(this.spawnAnimationID);
                      this.isSpelling = true;
                    }
                  } else {
                    const p = thirdPersonController.transform.position.clone();
                    p.y += 5;
                    const dir = new Mathf.Vector3(0, 0, -1).applyQuaternion(Components.Camera.mainCamera.transform.rotation).normalize();
                    const ray = new PhysicsRapier.Physics.Ray(p, dir);
                    const rayHit = PhysicsRapier.PhysicsWorld.castRay(ray, 100, true, void 0, void 0, void 0, this.rigidBody.rigidBody);
                    if (rayHit) {
                      let hitPoint = ray.pointAt(rayHit.timeOfImpact);
                      const hitPointv = new Mathf.Vector3(hitPoint.x, hitPoint.y, hitPoint.z);
                      boxGO.transform.position.copy(hitPointv);
                      if (Input.GetMouseDown(MouseCodes.MOUSE_LEFT)) {
                        console.log("Moused");
                        Scene.Instantiate(this.spawnPrefab, hitPointv);
                      }
                    }
                    if (Math.abs(this.thirdPersonController.move.x) > Mathf.Epsilon || Math.abs(this.thirdPersonController.move.y) > Mathf.Epsilon) {
                      this.animator.CrossFadeTo(this.moveAnimationID);
                      this.isSpelling = false;
                    }
                  }
                }
              }
              const natureSpawner = playerGameObject.AddComponent(NatureSpawner);
              natureSpawner.spawnAnimationID = GetClipIndexByName(animator, "Spell_Simple_Idle_Loop");
              natureSpawner.moveAnimationID = GetClipIndexByName(animator, "Rig|Rig|Walk_Loop");
              natureSpawner.animator = animator;
              natureSpawner.rigidBody = playerRigidbody;
              natureSpawner.thirdPersonController = thirdPersonController;
              const tree = await GLTFLoader.loadAsGameObjects(scene, "/extra/test-assets/Stylized Nature MegaKit[Standard]/glTF/CommonTree_1.gltf");
              natureSpawner.spawnPrefab = tree;
              console.log(playerGameObject);
              const playerSettings = new UIFolder(Debugger.ui, "Player");
              const playerPosition = new UIVecStat(
                playerSettings,
                "Position:",
                { value: playerGameObject.transform.position.x, min: -1e3, max: 1e3, step: 1 },
                { value: playerGameObject.transform.position.y, min: -1e3, max: 1e3, step: 1 },
                { value: playerGameObject.transform.position.z, min: -1e3, max: 1e3, step: 1 },
                void 0,
                (value) => {
                  playerGameObject.transform.position.set(value.x, value.y, value.z);
                }
              );
              setInterval(() => {
                const p = playerGameObject.transform.position;
                playerPosition.SetValue(p.x, p.y, p.z);
              }, 100);
              {
                class FrustumInstance extends Components.InstancedMesh {
                  distance = 10;
                  amount = 100;
                  scale = new Mathf.Vector3(1, 1, 1);
                  rotation = new Mathf.Vector3(0, 0, 0);
                  ground_height = 0;
                  target;
                  heightSamplingFunction = (point) => {
                    return 0;
                  };
                  randomPointInAnnulus(center, innerRadius, outerRadius) {
                    const angle = Mathf.RandomRange(0, 1) * Math.PI * 2;
                    const inner2 = innerRadius * innerRadius;
                    const outer2 = outerRadius * outerRadius;
                    const radius = Math.sqrt(Mathf.RandomRange(inner2, outer2));
                    return new Mathf.Vector3(
                      center.x + Math.cos(angle) * radius,
                      center.y,
                      center.z + Math.sin(angle) * radius
                    );
                  }
                  randomPointOnCircle(center, radius) {
                    const angle = Mathf.RandomRange(0, 1) * Math.PI * 2;
                    const uniformRadius = radius * Math.sqrt(Mathf.RandomRange(0, 1));
                    return new Mathf.Vector3(center.x + Math.cos(angle) * uniformRadius, center.y, center.z + Math.sin(angle) * uniformRadius);
                  }
                  Start() {
                    if (!this.target) throw Error("No transform");
                    if (!this.geometry || !this.material) throw Error("No geometry or material");
                    const p = new Mathf.Vector3();
                    const r = new Mathf.Quaternion();
                    const _euler = new Mathf.Vector3();
                    const c = this.amount;
                    const calculateNewPosition = (target, minRadius, maxRadius) => {
                      const m = new Mathf.Matrix4();
                      _euler.set(
                        Mathf.RandomRange(-10, 10) * Mathf.Deg2Rad,
                        Mathf.RandomRange(0, 360) * Mathf.Deg2Rad,
                        0
                      ).add(this.rotation);
                      r.fromEuler(_euler);
                      const objectCenter = minRadius <= 0 ? this.randomPointOnCircle(target, maxRadius) : this.randomPointInAnnulus(target, minRadius, maxRadius);
                      p.copy(objectCenter);
                      p.y = this.heightSamplingFunction(p);
                      p.y += this.scale.y * 0.5;
                      p.y += this.ground_height;
                      m.compose(p, r, this.scale);
                      return m;
                    };
                    let instances = [];
                    for (let i = 0; i < c; i++) {
                      const mat2 = calculateNewPosition(this.target.position, 0, this.distance);
                      this.SetMatrixAt(i, mat2);
                      instances.push({ i, m: mat2 });
                    }
                    setInterval(() => {
                      for (const instance of instances) {
                        instance.m.decompose(p, r, this.scale);
                        const dist = this.target.position.distanceTo(p);
                        if (dist > this.distance) {
                          const inner = this.distance * 0.7;
                          const outer = this.distance;
                          const mat2 = calculateNewPosition(this.target.position, inner, outer);
                          this.SetMatrixAt(instance.i, mat2);
                          instance.m = mat2;
                        }
                      }
                    }, 1e3);
                  }
                }
                const treeBillboard = await GLTFLoader.loadAsGameObjects(scene, "/extra/test-assets/Stylized Nature MegaKit[Standard]/glTF/CommonTree_1.gltf");
                let treeGeometry = void 0;
                let treeMaterial = void 0;
                traverse([treeBillboard], (gameObject) => {
                  const mesh = gameObject.GetComponent(Components.Mesh);
                  if (mesh) {
                    treeGeometry = mesh.geometry;
                    treeMaterial = mesh.material;
                  }
                });
                if (!treeGeometry || !treeMaterial) throw Error("No tree geometry or material");
                const billboards = [
                  { geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc008.png", "rgba8unorm", false, true), alphaCutoff: 0.5, albedoColor: Mathf.Color.fromHex(1886417151) }), amount: 5e4, distance: 200, ground_height: 0, scale: new Mathf.Vector3(1, 1, 1) },
                  // {geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc008.png", "rgba8unorm", false, true), alphaCutoff: 0.5, albedoColor: Mathf.Color.fromHex(0x707070ff) }), amount: 5000, distance: 500, ground_height: 0, scale: new Mathf.Vector3(1,1,1)},
                  // {texture: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc007.png"), amount: 10000, distance: 50, ground_height: 0, scale: new Mathf.Vector3(1,1,1)},
                  // {geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/trees/tree002.png", "rgba8unorm", false, true), alphaCutoff: 0.5, unlit: false}), amount: 100, distance: 50, ground_height: 2, scale: new Mathf.Vector3(5,5,5)},
                  { geometry: treeGeometry, material: treeMaterial, amount: 1e3, distance: 300, ground_height: 8, scale: new Mathf.Vector3(1, 1, 1), rotation: new Mathf.Vector3(-Math.PI / 2, 0, 0) }
                ];
                const treesGameObject = new GameObject(scene);
                for (const billboard of billboards) {
                  const treesInstance = treesGameObject.AddComponent(FrustumInstance);
                  treesInstance.amount = billboard.amount;
                  treesInstance.distance = billboard.distance;
                  treesInstance.ground_height = billboard.ground_height;
                  treesInstance.scale = billboard.scale;
                  treesInstance.target = playerGameObject.transform;
                  if (billboard.rotation) treesInstance.rotation = billboard.rotation;
                  treesInstance.enableShadows = false;
                  treesInstance.geometry = billboard.geometry;
                  treesInstance.material = billboard.material;
                  treesInstance.heightSamplingFunction = (p) => {
                    return terrain.SampleHeight(p);
                  };
                }
              }
              scene.renderPipeline.DeferredShadowMapPass.Settings.splitTypePracticalLambda = 0.99;
              mainCameraGameObject.transform.position.set(0, 0, 500);
              new OrbitControls(GPU.Renderer.canvas, camera);
              Debugger.Enable();
              scene.Start();
            }
            Application(document.querySelector("canvas"));
            
            </script>
        </body>
    </html>