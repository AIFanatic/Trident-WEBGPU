
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
            <meta name="mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-capable" content="yes">
            
            <style>
                html, body {
                    margin: 0;
                    overflow: hidden;
                    width: 100%;
                    height: 100%;
                }
            </style>
        </head>
        <body>
            <script type="importmap">
                {
                    "imports": {
                        "@trident/core": "../trident-core.js",
                        "@trident/plugins/": "../plugins/"
                    }
                }
            </script>
            <script type="module">
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                            import { GPU, Scene, GameObject, Components, Mathf, Geometry, Console } from '@trident/core';
            import { PhysicsRapier } from '@trident/plugins/PhysicsRapier/PhysicsRapier.js';
            import { TerrainCollider } from '@trident/plugins/PhysicsRapier/colliders/TerrainCollider.js';
            import { CapsuleCollider } from '@trident/plugins/PhysicsRapier/colliders/CapsuleCollider.js';
            import { ThirdPersonController } from '@trident/plugins/PhysicsRapier/ThirdPersonController.js';
            import { RigidBody, RigidbodyConstraints } from '@trident/plugins/PhysicsRapier/RigidBody.js';
            import { Debugger } from '@trident/plugins/Debugger.js';
            import { HDRParser } from '@trident/plugins/HDRParser.js';
            import { GLTFLoader } from '@trident/plugins/GLTF/GLTFLoader.js';
            import { UIColorStat, UIButtonStat, UISliderStat } from '@trident/plugins/ui/UIStats.js';
            import { Terrain } from '@trident/plugins/Terrain/Terrain.js';
            import { Water } from '@trident/plugins/Water/WaterPlugin.js';
            import { PostProcessingPass } from '@trident/plugins/PostProcessing/PostProcessingPass.js';
            import { PostProcessingSMAA } from '@trident/plugins/PostProcessing/effects/SMAA.js';
            import { Environment } from '@trident/plugins/Environment/Environment.js';
            import { LODInstanceRenderable } from '@trident/plugins/LODGroup.js';
            
            async function Application(canvas) {
              const renderer = GPU.Renderer.Create(canvas, "webgpu", 1);
              const scene = new Scene(renderer);
              const mainCameraGameObject = new GameObject(scene);
              mainCameraGameObject.transform.position.set(0, 0, 5);
              mainCameraGameObject.name = "MainCamera";
              const camera = mainCameraGameObject.AddComponent(Components.Camera);
              camera.SetPerspective(70, canvas.width / canvas.height, 0.2, 1e4);
              mainCameraGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const lightGameObject = new GameObject(scene);
              lightGameObject.transform.position.set(4, 4, 4).mul(10);
              lightGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const light = lightGameObject.AddComponent(Components.DirectionalLight);
              light.color.set(1, 0.96, 0.88, 1);
              light.intensity = 1;
              new UIColorStat(Debugger.ui, "Light Color:", light.color.toHex(), (value) => {
                light.color.setFromHex(value);
              });
              const physicsWorld = new GameObject(scene);
              const physicsComponent = physicsWorld.AddComponent(PhysicsRapier);
              await physicsComponent.Load();
              const terrainGameObject = new GameObject(scene);
              const terrain = terrainGameObject.AddComponent(Terrain);
              terrain.width = 1e3;
              terrain.length = 1e3;
              terrain.height = 200;
              await terrain.HeightmapFromPNG("/extra/test-assets/terrain/heightmaps/elevation_1024x1024.png", true, 0.25);
              async function LoadTerrainTextures(urls) {
                let textures = [];
                for (const url of urls) {
                  const texture = await GPU.Texture.Load(url);
                  texture.GenerateMips();
                  textures.push(texture);
                }
                return textures;
              }
              async function LoadTexture(url, format = "rgba8unorm-srgb") {
                const texture = await GPU.Texture.Load(url, format);
                texture.GenerateMips();
                return texture;
              }
              const biomes_splat_map = await GPU.Texture.Load("/extra/test-assets/terrain/heightmaps/biomeids_1024x1024.png");
              biomes_splat_map.GenerateMips();
              terrain.material.layerTexture = biomes_splat_map;
              terrain.material.splatMapTextures = await LoadTerrainTextures([
                "/extra/test-assets/terrain/heightmaps/splatmap_1024x1024.png"
                //"/extra/test-assets/terrain/heightmaps/splat0_island_1024x1024.png",
              ]);
              let transform = new Float32Array([10, 10, 0, 0]);
              const albedoTexture = await LoadTexture(`/extra/test-assets/terrain/rocky_terrain_02_2k/rocky_terrain_02_diff_2k.jpg`, "rgba8unorm-srgb");
              const normalTexture = await LoadTexture(`/extra/test-assets/terrain/rocky_terrain_02_2k/rocky_terrain_02_nor_gl_2k.jpg`, "rgba8unorm");
              const armMap = await LoadTexture(`/extra/test-assets/terrain/rocky_terrain_02_2k/rocky_terrain_02_arm_2k.jpg`, "rgba8unorm");
              terrain.material.layers = [
                { name: "TropicalForest", transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap }
              ];
              const heightsSize = Math.sqrt(terrain.heights.length);
              console.log(heightsSize);
              terrainGameObject.transform.position.z -= terrain.width * 0.5;
              terrainGameObject.transform.position.x -= terrain.length * 0.5;
              const terrainCollider = terrainGameObject.AddComponent(TerrainCollider);
              terrainCollider.SetTerrainData(heightsSize - 1, heightsSize - 1, terrain.heights, terrainGameObject.transform.scale);
              const hdr = await HDRParser.Load("/dist/examples/assets/textures/HDR/autumn_field_puresky_1k.hdr");
              const skyTexture = await HDRParser.ToCubemap(hdr);
              const environment = new Environment(scene, skyTexture);
              await environment.init();
              function traverse(gameObjects, fn) {
                for (const gameObject of gameObjects) {
                  fn(gameObject);
                  for (const child of gameObject.transform.children) {
                    traverse([child.gameObject], fn);
                  }
                }
              }
              const sceneGameObject = await GLTFLoader.loadAsGameObjects(scene, "./assets/models/Shadow.glb");
              let animator = void 0;
              traverse([sceneGameObject], (gameObject) => {
                const _animator = gameObject.GetComponent(Components.Animator);
                if (_animator) animator = _animator;
              });
              if (!animator) throw Error("Could not find an animator component");
              function GetClipIndexByName(animator2, name, partialMatch = true) {
                for (let i = 0; i < animator2.clips.length; i++) {
                  animator2.clips[i];
                  if (partialMatch && animator2.clips[i].name.toLowerCase().includes(name.toLocaleLowerCase())) return i;
                  else if (animator2.clips[i].name === name) return i;
                }
                return -1;
              }
              const playerGameObject = new GameObject(scene);
              playerGameObject.transform.position.set(20, 33, 185);
              playerGameObject.AddComponent(CapsuleCollider);
              const playerRigidbody = playerGameObject.AddComponent(RigidBody);
              playerRigidbody.Create("dynamic");
              playerRigidbody.constraints = RigidbodyConstraints.FreezeRotation;
              const thirdPersonController = playerGameObject.AddComponent(ThirdPersonController);
              thirdPersonController._controller = playerRigidbody;
              thirdPersonController._model = sceneGameObject;
              thirdPersonController._mainCamera = camera.gameObject;
              thirdPersonController._animator = animator;
              thirdPersonController._animationIDS = { idle: GetClipIndexByName(animator, "Rig|Rig|Idle_Loop", false), walk: GetClipIndexByName(animator, "Rig|Rig|Walk_Loop", false), sprint: GetClipIndexByName(animator, "sprint"), jump: GetClipIndexByName(animator, "Jump_Start"), fall: GetClipIndexByName(animator, "fall") };
              thirdPersonController.animationSpeedRatio = 0.8;
              thirdPersonController.boostMultiplier = 20;
              {
                async function TerrainObjectSpawner(glbURL, count, _options) {
                  const defaults = { spawnAroundTarget: void 0, enableShadows: true, heightRandom: -0.5 };
                  const options = Object.assign({}, defaults, _options);
                  const tree1 = await GLTFLoader.loadAsGameObjects(scene, glbURL);
                  let lodGroupEntries = [];
                  traverse([tree1], (gameObject) => {
                    const mesh = gameObject.GetComponent(Components.Mesh);
                    if (mesh) {
                      const geometrySerialized = mesh.geometry.Serialize();
                      const materialSerialized = mesh.material.Serialize();
                      console.log(materialSerialized.params);
                      materialSerialized.params.doubleSided = true;
                      const materialClone = GPU.Material.Deserialize(materialSerialized);
                      const geometryClone = new Geometry();
                      geometryClone.Deserialize(geometrySerialized);
                      lodGroupEntries.push({ geometry: geometryClone, material: materialClone });
                    }
                  });
                  tree1.Destroy();
                  const lodGameObject = new GameObject(scene);
                  const lodInstanceRenderable = lodGameObject.AddComponent(LODInstanceRenderable);
                  if (lodGroupEntries.length >= 2) lodInstanceRenderable.lods.push({ renderers: lodGroupEntries.slice(0, 2), screenSize: 10 });
                  if (lodGroupEntries.length >= 4) lodInstanceRenderable.lods.push({ renderers: lodGroupEntries.slice(2, 4), screenSize: 20 });
                  if (lodGroupEntries.length >= 6) lodInstanceRenderable.lods.push({ renderers: lodGroupEntries.slice(4, 6), screenSize: 100 });
                  if (lodGroupEntries.length >= 7) lodInstanceRenderable.lods.push({ renderers: lodGroupEntries.slice(6, 7), screenSize: 300 });
                  else if (lodGroupEntries.length >= 1) lodInstanceRenderable.lods.push({ renderers: lodGroupEntries.slice(0, 1), screenSize: 300 });
                  lodInstanceRenderable.enableShadows = options.enableShadows;
                  const p = new Mathf.Vector3();
                  const r = new Mathf.Vector3();
                  const q = new Mathf.Quaternion();
                  const s = new Mathf.Vector3(1, 1, 1);
                  const m = new Mathf.Matrix4();
                  const c = count;
                  const off = 500;
                  let treeCount = 0;
                  for (let i = 0; i < c; i++) {
                    let x = Mathf.RandomRange(-off, off);
                    let z = Mathf.RandomRange(-off, off);
                    if (options.spawnAroundTarget) {
                      const angle = i / c * Math.PI * 2;
                      const radius = Mathf.RandomRange(0, 200);
                      x = options.spawnAroundTarget.x + Mathf.Cos(angle) * radius;
                      z = options.spawnAroundTarget.z + Mathf.Sin(angle) * radius;
                    }
                    p.set(x, 0, z);
                    terrain.SampleHeight(p);
                    r.y = Mathf.RandomRange(0, 360);
                    q.setFromEuler(r);
                    if (options.heightRandom) {
                      p.y += Mathf.RandomRange(options.heightRandom, 0);
                    }
                    m.compose(p, q, s);
                    if (p.y > 25 && p.y < 100) {
                      lodInstanceRenderable.SetMatrixAt(treeCount, m);
                      treeCount++;
                    }
                  }
                  console.log(treeCount);
                }
                const ta = 5e3;
                await TerrainObjectSpawner("/extra/test-assets/Mountain Environment/Pine_trees/Prefabs/Prefab_Forest_pine_01.glb", ta);
                {
                  const tree1 = await GLTFLoader.loadAsGameObjects(scene, "/extra/test-assets/Mountain Environment/Foliage and Grass/Prefabs/Prefab_grass_01_1.glb");
                  let lodGroupEntries = [];
                  traverse([tree1], (gameObject2) => {
                    const mesh = gameObject2.GetComponent(Components.Mesh);
                    if (mesh) {
                      const geometrySerialized = mesh.geometry.Serialize();
                      const materialSerialized = mesh.material.Serialize();
                      const materialClone = GPU.Material.Deserialize(materialSerialized);
                      const geometryClone = new Geometry();
                      geometryClone.Deserialize(geometrySerialized);
                      lodGroupEntries.push({ geometry: geometryClone, material: materialClone });
                    }
                  });
                  tree1.Destroy();
                  const gameObject = new GameObject(scene);
                  const instancedMesh = gameObject.AddComponent(Components.InstancedMesh);
                  instancedMesh.enableShadows = false;
                  console.log(lodGroupEntries);
                  instancedMesh.geometry = lodGroupEntries[0].geometry;
                  instancedMesh.material = lodGroupEntries[0].material;
                  const count = 1e5;
                  const p = new Mathf.Vector3();
                  const r = new Mathf.Vector3();
                  const q = new Mathf.Quaternion();
                  const s = new Mathf.Vector3(1, 1, 1);
                  const m = new Mathf.Matrix4();
                  const c = count;
                  const off = 500;
                  let treeCount = 0;
                  for (let i = 0; i < c; i++) {
                    let x = Mathf.RandomRange(-off, off);
                    let z = Mathf.RandomRange(-off, off);
                    p.set(x, 0, z);
                    terrain.SampleHeight(p);
                    r.y = Mathf.RandomRange(0, 360);
                    q.setFromEuler(r);
                    m.compose(p, q, s);
                    if (p.y > 25) {
                      instancedMesh.SetMatrixAt(treeCount, m);
                      treeCount++;
                    }
                  }
                }
              }
              {
                const scale = 1e3;
                const waterGameObject = new GameObject(scene);
                waterGameObject.transform.scale.set(scale, scale, 1);
                waterGameObject.transform.eulerAngles.x = -90;
                waterGameObject.transform.position.y = 25;
                const water = waterGameObject.AddComponent(Water);
                new UIColorStat(Debugger.ui, "Color deep:", new Mathf.Color(...water.settings.get("color_deep")).toHex().slice(0, 7), (value) => {
                  const c = Mathf.Color.fromHex(parseInt(value.slice(1, value.length), 16));
                  water.settings.set("color_deep", [c.r, c.g, c.b, c.a]);
                });
                new UIColorStat(Debugger.ui, "Color shallow:", new Mathf.Color(...water.settings.get("color_shallow")).toHex().slice(0, 7), (value) => {
                  const c = Mathf.Color.fromHex(parseInt(value.slice(1, value.length), 16));
                  water.settings.set("color_shallow", [c.r, c.g, c.b, c.a]);
                });
              }
              Console.getVar("r_exposure").value = 0;
              Console.getVar("r_shadows_csm_splittypepracticallambda").value = 0.99;
              mainCameraGameObject.transform.position.set(0, 0, 500);
              const postProcessing = new PostProcessingPass();
              const smaa = new PostProcessingSMAA();
              postProcessing.effects.push(smaa);
              scene.renderPipeline.AddPass(postProcessing, GPU.RenderPassOrder.BeforeScreenOutput);
              new UIButtonStat(Debugger.ui, "Disable SMAA:", async (value) => {
                smaa.enabled = value;
              });
              new UISliderStat(Debugger.ui, "Exposure:", -4, 4, 0.1, Console.getVar("r_exposure").value, (value) => Console.getVar("r_exposure").value = value);
              new UISliderStat(Debugger.ui, "Saturation:", -4, 4, 0.1, Console.getVar("r_saturation").value, (value) => Console.getVar("r_saturation").value = value);
              new UISliderStat(Debugger.ui, "Contrast:", -4, 4, 0.1, Console.getVar("r_contrast").value, (value) => Console.getVar("r_contrast").value = value);
              Debugger.Enable();
              {
                window.addEventListener("dragover", (e) => {
                  e.preventDefault();
                });
                window.addEventListener("drop", async (e) => {
                  e.preventDefault();
                  const file = e.dataTransfer?.files?.[0];
                  if (!file) return;
                  const url = URL.createObjectURL(file);
                  const obj = await GLTFLoader.loadAsGameObjects(scene, url, "glb");
                  obj.transform.position.copy(playerGameObject.transform.position);
                });
              }
              scene.Start();
            }
            Application(document.querySelector("canvas"));
            
            </script>
        </body>
    </html>