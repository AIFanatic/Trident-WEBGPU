
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
            <meta name="mobile-web-app-capable" content="yes">
            <meta name="apple-mobile-web-app-capable" content="yes">
            
            <style>
                html, body {
                    margin: 0;
                    overflow: hidden;
                    height: 100%;
                    width: 100%;
                }
            </style>
        </head>
        <body>
            <script type="importmap">
                {
                    "imports": {
                        "@trident/core": "../trident-core.js",
                        "@trident/plugins/": "../plugins/"
                    }
                }
            </script>
            <script type="module">
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                            import { GPU, Scene, GameObject, Components, Mathf, Geometry, PBRMaterial, Input, KeyCodes, MouseCodes, Console, Component } from '@trident/core';
            import { PhysicsRapier } from '@trident/plugins/PhysicsRapier/PhysicsRapier.js';
            import { TerrainCollider } from '@trident/plugins/PhysicsRapier/colliders/TerrainCollider.js';
            import { CapsuleCollider } from '@trident/plugins/PhysicsRapier/colliders/CapsuleCollider.js';
            import { BoxCollider } from '@trident/plugins/PhysicsRapier/colliders/BoxCollider.js';
            import { ThirdPersonController } from '@trident/plugins/PhysicsRapier/ThirdPersonController.js';
            import { RigidBody, RigidbodyConstraints } from '@trident/plugins/PhysicsRapier/RigidBody.js';
            import { Debugger } from '@trident/plugins/Debugger.js';
            import { GLTFLoader } from '@trident/plugins/GLTF/GLTFLoader.js';
            import { UIFolder, UISliderStat, UIButtonStat, UIVecStat, UIColorStat } from '@trident/plugins/ui/UIStats.js';
            import { OrbitControls } from '@trident/plugins/OrbitControls.js';
            import { Terrain } from '@trident/plugins/Terrain/Terrain.js';
            import { Water } from '@trident/plugins/Water/WaterPlugin.js';
            import { Sky } from '@trident/plugins/Environment/Sky.js';
            import { Environment } from '@trident/plugins/Environment/Environment.js';
            
            async function Application(canvas) {
              const renderer = GPU.Renderer.Create(canvas, "webgpu");
              const scene = new Scene(renderer);
              const mainCameraGameObject = new GameObject(scene);
              mainCameraGameObject.transform.position.set(0, 0, 5);
              mainCameraGameObject.name = "MainCamera";
              const camera = mainCameraGameObject.AddComponent(Components.Camera);
              camera.SetPerspective(70, canvas.width / canvas.height, 0.2, 1e4);
              mainCameraGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const lightGameObject = new GameObject(scene);
              lightGameObject.transform.position.set(4, 4, 4).mul(10);
              lightGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
              const light = lightGameObject.AddComponent(Components.DirectionalLight);
              light.intensity = 10;
              const physicsWorld = new GameObject(scene);
              const physicsComponent = physicsWorld.AddComponent(PhysicsRapier);
              await physicsComponent.Load();
              const terrainGameObject = new GameObject(scene);
              const terrain = terrainGameObject.AddComponent(Terrain);
              terrain.width = 1e3;
              terrain.length = 1e3;
              terrain.height = 200;
              await terrain.HeightmapFromPNG("/extra/test-assets/terrain/heightmaps/elevation_1024x1024.png", true, 0.25);
              async function LoadTerrainTextures(urls) {
                let textures = [];
                for (const url of urls) {
                  const texture = await GPU.Texture.Load(url);
                  texture.GenerateMips();
                  textures.push(texture);
                }
                return textures;
              }
              async function LoadTexture(url, format = "rgba8unorm-srgb") {
                const texture = await GPU.Texture.Load(url, format);
                texture.GenerateMips();
                return texture;
              }
              const biomes_splat_map = await GPU.Texture.Load("/extra/test-assets/terrain/heightmaps/biomeids_1024x1024.png");
              biomes_splat_map.GenerateMips();
              console.log(terrain);
              terrain.material.layerTexture = biomes_splat_map;
              terrain.material.splatMapTextures = await LoadTerrainTextures([
                "/extra/test-assets/terrain/heightmaps/splatmap_1024x1024.png"
                //"/extra/test-assets/terrain/heightmaps/splat0_island_1024x1024.png",
              ]);
              let transform = new Float32Array([2, 2, 0, 0]);
              const albedoTexture = await LoadTexture(`/extra/test-assets/terrain/Terrain_Textures_v2/T_ground_grass_01_BC_SM.png`, "rgba8unorm-srgb");
              const normalTexture = await LoadTexture(`/extra/test-assets/terrain/Terrain_Textures_v2/T_ground_grass_01_N.png`, "rgba8unorm");
              const armMap = await LoadTexture(`/extra/test-assets/terrain/Terrain_Textures_v2/T_ground_grass_01_MT_AO_H_SM.png`, "rgba8unorm");
              terrain.material.layers = [
                { name: "TropicalForest", transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                // { name: `Water`, transform: transform, albedoMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_BaseColor.png`), normalMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_Normal.png`), armMap: await LoadTexture(basePath + `/Asphalt 01/Asphalt 01_MaskMap.png`) },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap },
                { name: `TropicalForest`, transform, albedoMap: albedoTexture, normalMap: normalTexture, armMap }
              ];
              const heightsSize = Math.sqrt(terrain.heights.length);
              console.log(heightsSize);
              terrainGameObject.transform.position.z -= terrain.width * 0.5;
              terrainGameObject.transform.position.x -= terrain.length * 0.5;
              const terrainCollider = terrainGameObject.AddComponent(TerrainCollider);
              terrainCollider.SetTerrainData(heightsSize - 1, heightsSize - 1, terrain.heights, terrainGameObject.transform.scale);
              {
                {
                  const boxGO2 = new GameObject(scene);
                  boxGO2.transform.position.y = 200;
                  boxGO2.transform.scale.set(1, 1, 1);
                  const boxMesh2 = boxGO2.AddComponent(Components.Mesh);
                  boxMesh2.geometry = Geometry.Cube();
                  boxMesh2.material = new PBRMaterial({ albedoColor: new Mathf.Color(1, 0, 0, 1), roughness: 0.3 });
                  boxGO2.AddComponent(BoxCollider);
                  const rigidbody = boxGO2.AddComponent(RigidBody);
                  rigidbody.Create("fixed");
                }
              }
              const skyAtmosphere = new Sky();
              await skyAtmosphere.init();
              const skyTexture = skyAtmosphere.skyTextureCubemap;
              const environment = new Environment(scene, skyTexture);
              await environment.init();
              {
                const skySettings = new UIFolder(Debugger.ui, "Sky");
                new UISliderStat(skySettings, "SUN_ELEVATION_DEGREES:", 0, 180, 0.01, skyAtmosphere.SUN_ELEVATION_DEGREES, (value) => skyAtmosphere.SUN_ELEVATION_DEGREES = value);
                new UISliderStat(skySettings, "EYE_ALTITUDE:", 0, 1e3, 0.01, skyAtmosphere.EYE_ALTITUDE, (value) => skyAtmosphere.EYE_ALTITUDE = value);
                new UIButtonStat(skySettings, "Rebuild:", async (value) => {
                  skyAtmosphere.Update();
                  environment.Update();
                });
                skySettings.Open();
              }
              function traverse(gameObjects, fn) {
                for (const gameObject of gameObjects) {
                  fn(gameObject);
                  for (const child of gameObject.transform.children) {
                    traverse([child.gameObject], fn);
                  }
                }
              }
              const sceneGameObject = await GLTFLoader.loadAsGameObjects(scene, "./assets/models/Shadow.glb");
              let animator = void 0;
              traverse([sceneGameObject], (gameObject) => {
                const _animator = gameObject.GetComponent(Components.Animator);
                if (_animator) animator = _animator;
              });
              if (!animator) throw Error("Could not find an animator component");
              function GetClipIndexByName(animator2, name, partialMatch = true) {
                for (let i = 0; i < animator2.clips.length; i++) {
                  animator2.clips[i];
                  if (partialMatch && animator2.clips[i].name.toLowerCase().includes(name.toLocaleLowerCase())) return i;
                  else if (animator2.clips[i].name === name) return i;
                }
                return -1;
              }
              const playerGameObject = new GameObject(scene);
              playerGameObject.transform.position.set(-125, 30, 255);
              playerGameObject.AddComponent(CapsuleCollider);
              const playerRigidbody = playerGameObject.AddComponent(RigidBody);
              playerRigidbody.Create("dynamic");
              playerRigidbody.constraints = RigidbodyConstraints.FreezeRotation;
              const thirdPersonController = playerGameObject.AddComponent(ThirdPersonController);
              thirdPersonController._controller = playerRigidbody;
              thirdPersonController._model = sceneGameObject;
              thirdPersonController._mainCamera = camera.gameObject;
              thirdPersonController._animator = animator;
              thirdPersonController._animationIDS = { idle: GetClipIndexByName(animator, "Rig|Rig|Idle_Loop", false), walk: GetClipIndexByName(animator, "Rig|Rig|Walk_Loop", false), sprint: GetClipIndexByName(animator, "sprint"), jump: GetClipIndexByName(animator, "Jump_Start"), fall: GetClipIndexByName(animator, "fall") };
              thirdPersonController.animationSpeedRatio = 0.8;
              thirdPersonController.boostMultiplier = 20;
              const boxGO = new GameObject(scene);
              boxGO.transform.position.y = 1.5;
              boxGO.transform.position.x = 2;
              const boxMesh = boxGO.AddComponent(Components.Mesh);
              boxMesh.geometry = Geometry.Cube();
              boxMesh.material = new PBRMaterial({ albedoColor: new Mathf.Color(0, 1, 0, 1) });
              class NatureSpawner extends Components.Component {
                spawnAnimationID = -1;
                moveAnimationID = -1;
                animator;
                thirdPersonController;
                rigidBody;
                spawnPrefab;
                isSpelling = false;
                Start() {
                  if (!this.animator) throw Error("No animator");
                  if (!this.thirdPersonController) throw Error("No thirdPersonController");
                  if (!this.rigidBody) throw Error("No rigidbody");
                  if (!this.spawnPrefab) throw Error("No spawnPrefab");
                }
                Update() {
                  if (!this.isSpelling) {
                    if (Input.GetKey(KeyCodes.Q)) {
                      this.animator.CrossFadeTo(this.spawnAnimationID);
                      this.isSpelling = true;
                    }
                  } else {
                    const p = thirdPersonController.transform.position.clone();
                    p.y += 5;
                    const dir = new Mathf.Vector3(0, 0, -1).applyQuaternion(Components.Camera.mainCamera.transform.rotation).normalize();
                    const ray = new PhysicsRapier.Physics.Ray(p, dir);
                    const rayHit = PhysicsRapier.PhysicsWorld.castRay(ray, 100, true, void 0, void 0, void 0, this.rigidBody.rigidBody);
                    if (rayHit) {
                      let hitPoint = ray.pointAt(rayHit.timeOfImpact);
                      const hitPointv = new Mathf.Vector3(hitPoint.x, hitPoint.y, hitPoint.z);
                      boxGO.transform.position.copy(hitPointv);
                      if (Input.GetMouseDown(MouseCodes.MOUSE_LEFT)) {
                        console.log("Moused");
                        Scene.Instantiate(this.spawnPrefab, hitPointv);
                      }
                    }
                    if (Math.abs(this.thirdPersonController.move.x) > Mathf.Epsilon || Math.abs(this.thirdPersonController.move.y) > Mathf.Epsilon) {
                      this.animator.CrossFadeTo(this.moveAnimationID);
                      this.isSpelling = false;
                    }
                  }
                }
              }
              const natureSpawner = playerGameObject.AddComponent(NatureSpawner);
              natureSpawner.spawnAnimationID = GetClipIndexByName(animator, "Spell_Simple_Idle_Loop");
              natureSpawner.moveAnimationID = GetClipIndexByName(animator, "Rig|Rig|Walk_Loop");
              natureSpawner.animator = animator;
              natureSpawner.rigidBody = playerRigidbody;
              natureSpawner.thirdPersonController = thirdPersonController;
              const tree = await GLTFLoader.loadAsGameObjects(scene, "/extra/test-assets/Stylized Nature MegaKit[Standard]/glTF/CommonTree_1.gltf");
              natureSpawner.spawnPrefab = tree;
              console.log(playerGameObject);
              const playerSettings = new UIFolder(Debugger.ui, "Player");
              const playerPosition = new UIVecStat(
                playerSettings,
                "Position:",
                { value: playerGameObject.transform.position.x, min: -1e3, max: 1e3, step: 1 },
                { value: playerGameObject.transform.position.y, min: -1e3, max: 1e3, step: 1 },
                { value: playerGameObject.transform.position.z, min: -1e3, max: 1e3, step: 1 },
                void 0,
                (value) => {
                  playerGameObject.transform.position.set(value.x, value.y, value.z);
                }
              );
              setInterval(() => {
                const p = playerGameObject.transform.position;
                playerPosition.SetValue(p.x, p.y, p.z);
              }, 100);
              {
                class FrustumInstance extends Components.InstancedMesh {
                  distance = 10;
                  amount = 100;
                  scale = new Mathf.Vector3(1, 1, 1);
                  rotation = new Mathf.Vector3(0, 0, 0);
                  ground_height = 0;
                  target;
                  heightSamplingFunction = (point) => {
                    return 0;
                  };
                  randomPointInAnnulus(center, innerRadius, outerRadius) {
                    const angle = Mathf.RandomRange(0, 1) * Math.PI * 2;
                    const inner2 = innerRadius * innerRadius;
                    const outer2 = outerRadius * outerRadius;
                    const radius = Math.sqrt(Mathf.RandomRange(inner2, outer2));
                    return new Mathf.Vector3(
                      center.x + Math.cos(angle) * radius,
                      center.y,
                      center.z + Math.sin(angle) * radius
                    );
                  }
                  randomPointOnCircle(center, radius) {
                    const angle = Mathf.RandomRange(0, 1) * Math.PI * 2;
                    const uniformRadius = radius * Math.sqrt(Mathf.RandomRange(0, 1));
                    return new Mathf.Vector3(center.x + Math.cos(angle) * uniformRadius, center.y, center.z + Math.sin(angle) * uniformRadius);
                  }
                  Start() {
                    if (!this.target) throw Error("No transform");
                    if (!this.geometry || !this.material) throw Error("No geometry or material");
                    const p = new Mathf.Vector3();
                    const r = new Mathf.Quaternion();
                    const _euler = new Mathf.Vector3();
                    const c = this.amount;
                    const calculateNewPosition = (target, minRadius, maxRadius) => {
                      const m = new Mathf.Matrix4();
                      _euler.set(
                        Mathf.RandomRange(-10, 10) * Mathf.Deg2Rad,
                        Mathf.RandomRange(0, 360) * Mathf.Deg2Rad,
                        0
                      ).add(this.rotation);
                      r.setFromEuler(_euler);
                      const objectCenter = minRadius <= 0 ? this.randomPointOnCircle(target, maxRadius) : this.randomPointInAnnulus(target, minRadius, maxRadius);
                      p.copy(objectCenter);
                      p.y = this.heightSamplingFunction(p);
                      p.y += this.scale.y * 0.5;
                      p.y += this.ground_height;
                      m.compose(p, r, this.scale);
                      return m;
                    };
                    let instances2 = [];
                    for (let i = 0; i < c; i++) {
                      const mat2 = calculateNewPosition(this.target.position, 0, this.distance);
                      this.SetMatrixAt(i, mat2);
                      instances2.push({ i, m: mat2 });
                    }
                    setInterval(() => {
                      for (const instance of instances2) {
                        instance.m.decompose(p, r, this.scale);
                        const dist = this.target.position.distanceTo(p);
                        if (dist > this.distance) {
                          const inner = this.distance * 0.7;
                          const outer = this.distance;
                          const mat2 = calculateNewPosition(this.target.position, inner, outer);
                          this.SetMatrixAt(instance.i, mat2);
                          instance.m = mat2;
                        }
                      }
                    }, 1e3);
                  }
                }
                const billboards = [
                  // { geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc008.png", "rgba8unorm", false, true), alphaCutoff: 0.5, albedoColor: Mathf.Color.fromHex(0x707070ff) }), amount: 100000, distance: 25, ground_height: 0, scale: new Mathf.Vector3(0.5, 0.5, 0.5) },
                  // {geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc008.png", "rgba8unorm", false, true), alphaCutoff: 0.5, albedoColor: Mathf.Color.fromHex(0x707070ff) }), amount: 5000, distance: 500, ground_height: 0, scale: new Mathf.Vector3(1,1,1)},
                  // {texture: await GPU.Texture.Load("/extra/test-assets/billboards/grass/grassbushcc007.png"), amount: 10000, distance: 50, ground_height: 0, scale: new Mathf.Vector3(1,1,1)},
                  // {geometry: Geometry.Plane(), material: new PBRMaterial({ albedoMap: await GPU.Texture.Load("/extra/test-assets/billboards/trees/tree002.png", "rgba8unorm", false, true), alphaCutoff: 0.5, unlit: false}), amount: 100, distance: 50, ground_height: 2, scale: new Mathf.Vector3(5,5,5)},
                  // {geometry: treeGeometry, material: treeMaterial, amount: 1000, distance: 300, ground_height: 8, scale: new Mathf.Vector3(1,1,1), rotation: new Mathf.Vector3(-Math.PI / 2,0,0)},
                ];
                const treesGameObject = new GameObject(scene);
                for (const billboard of billboards) {
                  const treesInstance = treesGameObject.AddComponent(FrustumInstance);
                  treesInstance.amount = billboard.amount;
                  treesInstance.distance = billboard.distance;
                  treesInstance.ground_height = billboard.ground_height;
                  treesInstance.scale = billboard.scale;
                  treesInstance.target = playerGameObject.transform;
                  if (billboard.rotation) treesInstance.rotation = billboard.rotation;
                  treesInstance.enableShadows = false;
                  treesInstance.geometry = billboard.geometry;
                  treesInstance.material = billboard.material;
                  treesInstance.heightSamplingFunction = (p) => {
                    return terrain.SampleHeight(p);
                  };
                }
              }
              const commonTree = await GLTFLoader.loadAsGameObjects(scene, "/extra/test-assets/tree-02.glb");
              let instances = [];
              traverse([commonTree], (gameObject) => {
                const mesh = gameObject.GetComponent(Components.Mesh);
                if (mesh) {
                  instances.push({ geometry: mesh.geometry, material: mesh.material });
                }
              });
              class InstancedLODGroup extends Component {
                static type = "@trident/core/components/InstancedLODGroup";
                hysteresis = 5;
                lodLevels = [];
                instances = [];
                cameraPosition = new Mathf.Vector3();
                AddLevel(config) {
                  const level = {
                    mesh: this.gameObject.AddComponent(Components.InstancedMesh),
                    maxDistance: config.maxDistance ?? Number.POSITIVE_INFINITY,
                    minDistance: 0,
                    minDistanceSq: 0,
                    maxDistanceSq: Number.POSITIVE_INFINITY,
                    cursor: 0
                  };
                  level.mesh.geometry = config.geometry;
                  level.mesh.material = config.material;
                  this.lodLevels.push(level);
                  this.recalculateRanges();
                  return level.mesh;
                }
                SetMatrixAt(index, matrix) {
                  let slot = this.instances[index];
                  if (!slot) {
                    slot = { matrix: new Mathf.Matrix4(), position: new Mathf.Vector3(), lodIndex: -1 };
                    this.instances[index] = slot;
                  }
                  slot.matrix.copy(matrix);
                  slot.position.setFromMatrixPosition(matrix);
                }
                Update() {
                  if (!this.enabled || this.lodLevels.length === 0) return;
                  const camera2 = Components.Camera.mainCamera;
                  if (!camera2) return;
                  this.cameraPosition.copy(camera2.transform.position);
                  for (const level of this.lodLevels) {
                    level.cursor = 0;
                    level.mesh.ResetInstances();
                  }
                  for (const slot of this.instances) {
                    if (!slot) continue;
                    const distanceSq = slot.position.distanceToSquared(this.cameraPosition);
                    const target = this.selectLOD(distanceSq, slot.lodIndex);
                    slot.lodIndex = target;
                    const level = this.lodLevels[target];
                    level.mesh.SetMatrixAt(level.cursor++, slot.matrix);
                  }
                }
                selectLOD(distanceSq, previousLOD) {
                  if (previousLOD >= 0) {
                    const level = this.lodLevels[previousLOD];
                    const near = Math.max(0, level.minDistance - this.hysteresis);
                    const far = Number.isFinite(level.maxDistance) ? level.maxDistance + this.hysteresis : Number.POSITIVE_INFINITY;
                    const nearSq = near * near;
                    const farSq = Number.isFinite(far) ? far * far : Number.POSITIVE_INFINITY;
                    if (distanceSq >= nearSq && distanceSq < farSq) return previousLOD;
                  }
                  for (let i = 0; i < this.lodLevels.length; i++) {
                    if (distanceSq < this.lodLevels[i].maxDistanceSq) return i;
                  }
                  return this.lodLevels.length - 1;
                }
                recalculateRanges() {
                  this.lodLevels.sort((a, b) => a.maxDistance - b.maxDistance);
                  let previousMax = 0;
                  for (const level of this.lodLevels) {
                    level.minDistance = previousMax;
                    level.minDistanceSq = level.minDistance * level.minDistance;
                    level.maxDistanceSq = Number.isFinite(level.maxDistance) ? level.maxDistance * level.maxDistance : Number.POSITIVE_INFINITY;
                    previousMax = level.maxDistance;
                  }
                }
              }
              const lodTrees = terrainGameObject.AddComponent(InstancedLODGroup);
              lodTrees.hysteresis = 15;
              const mat = new PBRMaterial({ doubleSided: true });
              lodTrees.AddLevel({ geometry: Geometry.Sphere(), material: mat, maxDistance: 10 });
              lodTrees.AddLevel({ geometry: Geometry.Cube(), material: mat, maxDistance: 20 });
              lodTrees.AddLevel({ geometry: Geometry.Plane(), material: mat });
              {
                const p = new Mathf.Vector3();
                const r = new Mathf.Vector3();
                const _q = new Mathf.Quaternion();
                const s = new Mathf.Vector3(1, 1, 1);
                const m = new Mathf.Matrix4();
                const center = playerGameObject.transform.position;
                let c = 1e3;
                for (let i = 0; i < c; i++) {
                  const angle = i / c * Math.PI * 2;
                  const radius = Mathf.RandomRange(0, 100);
                  const x = center.x + Mathf.Cos(angle) * radius;
                  const z = center.z + Mathf.Sin(angle) * radius;
                  p.set(x, 0, z);
                  terrain.SampleHeight(p);
                  p.y += 0.5;
                  _q.setFromEuler(r, true);
                  m.compose(p, _q, s);
                  lodTrees.SetMatrixAt(i, m);
                }
              }
              {
                const scale = 1e3;
                const waterGameObject = new GameObject(scene);
                waterGameObject.transform.scale.set(scale, scale, 1);
                waterGameObject.transform.eulerAngles.x = -90;
                waterGameObject.transform.position.y = 18;
                const water = waterGameObject.AddComponent(Water);
                const invScale = 1 / scale;
                water.settings.set("sampler_scale", [invScale, invScale, 0, 0]);
                water.settings.set("uv_sampler_scale", [invScale, invScale, 0, 0]);
                const container = document.createElement("div");
                container.classList.add("stats-panel");
                document.body.append(container);
                const waterSettingsFolder = new UIFolder(Debugger.ui, "Water");
                new UISliderStat(waterSettingsFolder, "Wave speed:", -1, 1, 0.01, water.settings.get("wave_speed")[0], (value) => water.settings.set("wave_speed", [value, 0, 0, 0]));
                new UISliderStat(waterSettingsFolder, "Beers law:", -2, 20, 0.01, water.settings.get("beers_law")[0], (value) => water.settings.set("beers_law", [value, 0, 0, 0]));
                new UISliderStat(waterSettingsFolder, "Depth offset:", -1, 1, 0.01, water.settings.get("depth_offset")[0], (value) => water.settings.set("depth_offset", [value, 0, 0, 0]));
                new UISliderStat(waterSettingsFolder, "Refraction:", -1, 1, 0.01, water.settings.get("refraction")[0], (value) => water.settings.set("refraction", [value, 0, 0, 0]));
                new UISliderStat(waterSettingsFolder, "Foam level:", -10, 10, 0.01, water.settings.get("foam_level")[0], (value) => water.settings.set("foam_level", [value, 0, 0, 0]));
                new UIColorStat(waterSettingsFolder, "Color deep:", new Mathf.Color(...water.settings.get("color_deep")).toHex().slice(0, 7), (value) => {
                  const c = Mathf.Color.fromHex(parseInt(value.slice(1, value.length), 16));
                  water.settings.set("color_deep", [c.r, c.g, c.b, c.a]);
                });
                new UIColorStat(waterSettingsFolder, "Color shallow:", new Mathf.Color(...water.settings.get("color_shallow")).toHex().slice(0, 7), (value) => {
                  const c = Mathf.Color.fromHex(parseInt(value.slice(1, value.length), 16));
                  water.settings.set("color_shallow", [c.r, c.g, c.b, c.a]);
                });
                const wave_a = water.settings.get("wave_a");
                new UIVecStat(
                  waterSettingsFolder,
                  "Wave A:",
                  { value: wave_a[0], min: -1, max: 1, step: 0.01 },
                  { value: wave_a[1], min: -1, max: 1, step: 0.01 },
                  { value: wave_a[2], min: -1, max: 1, step: 0.01 },
                  { value: wave_a[3], min: -1, max: 1, step: 0.01 },
                  (value) => {
                    water.settings.set("wave_a", [value.x, value.y, value.z, value.w]);
                  }
                );
                const wave_b = water.settings.get("wave_b");
                new UIVecStat(
                  waterSettingsFolder,
                  "Wave B:",
                  { value: wave_b[0], min: -1, max: 1, step: 0.01 },
                  { value: wave_b[1], min: -1, max: 1, step: 0.01 },
                  { value: wave_b[2], min: -1, max: 1, step: 0.01 },
                  { value: wave_b[3], min: -1, max: 1, step: 0.01 },
                  (value) => {
                    water.settings.set("wave_b", [value.x, value.y, value.z, value.w]);
                  }
                );
                const wave_c = water.settings.get("wave_c");
                new UIVecStat(
                  waterSettingsFolder,
                  "Wave C:",
                  { value: wave_c[0], min: -1, max: 1, step: 0.01 },
                  { value: wave_c[1], min: -1, max: 1, step: 0.01 },
                  { value: wave_c[2], min: -1, max: 1, step: 0.01 },
                  { value: wave_c[3], min: -1, max: 1, step: 0.01 },
                  (value) => {
                    water.settings.set("wave_c", [value.x, value.y, value.z, value.w]);
                  }
                );
                const sampler_scale = water.settings.get("sampler_scale");
                new UIVecStat(
                  waterSettingsFolder,
                  "Sample scale:",
                  { value: sampler_scale[0], min: -5, max: 5, step: 0.01 },
                  { value: sampler_scale[1], min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  (value) => {
                    water.settings.set("sampler_scale", [value.x, value.y, 0, 0]);
                  }
                );
                const sampler_direction = water.settings.get("sampler_direction");
                new UIVecStat(
                  waterSettingsFolder,
                  "Sample direction:",
                  { value: sampler_direction[0], min: -5, max: 5, step: 0.01 },
                  { value: sampler_direction[1], min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  void 0,
                  (value) => {
                    water.settings.set("sampler_direction", [value.x, value.y, 0, 0]);
                  }
                );
                const uv_sampler_scale = water.settings.get("uv_sampler_scale");
                new UIVecStat(
                  waterSettingsFolder,
                  "UV Sampler scale:",
                  { value: uv_sampler_scale[0], min: -5, max: 5, step: 0.01 },
                  { value: uv_sampler_scale[1], min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  void 0,
                  (value) => {
                    water.settings.set("uv_sampler_scale", [value.x, value.y, 0, 0]);
                  }
                );
                const uv_sampler_strength = water.settings.get("uv_sampler_strength");
                new UIVecStat(
                  waterSettingsFolder,
                  "UV Sampler strength:",
                  { value: uv_sampler_strength[0], min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  { value: 0, min: -5, max: 5, step: 0.01 },
                  void 0,
                  (value) => {
                    water.settings.set("uv_sampler_strength", [value.x, 0, 0, 0]);
                  }
                );
                waterSettingsFolder.Open();
              }
              Console.getVar("r_exposure").value = -2;
              Console.getVar("r_shadows_csm_splittypepracticallambda").value = 0.99;
              mainCameraGameObject.transform.position.set(0, 0, 500);
              new OrbitControls(GPU.Renderer.canvas, camera);
              Debugger.Enable();
              scene.Start();
            }
            Application(document.querySelector("canvas"));
            
            </script>
        </body>
    </html>