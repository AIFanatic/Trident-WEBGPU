#include "@trident/core/resources/webgpu/shaders/deferred/ShadowMap.wgsl";

struct Settings {
    debugDepthPass: f32,
    debugDepthMipLevel: f32,
    debugDepthExposure: f32,
    viewType: f32,
    useHeightMap: f32,
    heightScale: f32,

    debugShadowCascades: f32,
    pcfResolution: f32,
    blendThreshold: f32,
    viewBlendThreshold: f32,

    cameraPosition: vec4<f32>,
};

struct DirectionalLight {
    direction: vec3<f32>,
    color: vec3<f32>,
    intensity: f32
};

struct SpotLight {
    pointToLight: vec3<f32>,
    color: vec3<f32>,
    direction: vec3<f32>,
    range: f32,
    intensity: f32,
    angle: f32,
};

struct PointLight {
    pointToLight: vec3<f32>,
    color: vec3<f32>,
    range: f32,
    intensity: f32,
};

struct VertexInput {
    @location(0) position : vec2<f32>,
    @location(1) normal : vec3<f32>,
    @location(2) uv : vec2<f32>,
};

struct VertexOutput {
    @builtin(position) position : vec4<f32>,
    @location(0) vUv : vec2<f32>,
};

@group(0) @binding(0) var textureSampler: sampler;

@group(0) @binding(1) var albedoTexture: texture_2d<f32>;
@group(0) @binding(2) var normalTexture: texture_2d<f32>;
@group(0) @binding(3) var ermoTexture: texture_2d<f32>;
@group(0) @binding(4) var depthTexture: texture_depth_2d;
@group(0) @binding(5) var shadowPassDepth: texture_depth_2d_array;

@group(0) @binding(6) var skyboxTexture: texture_cube<f32>;
@group(0) @binding(7) var skyboxIrradianceTexture: texture_cube<f32>;
@group(0) @binding(8) var skyboxPrefilterTexture: texture_cube<f32>;
@group(0) @binding(9) var skyboxBRDFLUT: texture_2d<f32>;

@group(0) @binding(10) var brdfSampler: sampler;


struct Light {
    position: vec4<f32>,
    projectionMatrix: mat4x4<f32>,
    // // Using an array of mat4x4 causes the render time to go from 3ms to 9ms for some reason
    // csmProjectionMatrix: array<mat4x4<f32>, 4>,
    csmProjectionMatrix0: mat4x4<f32>,
    csmProjectionMatrix1: mat4x4<f32>,
    csmProjectionMatrix2: mat4x4<f32>,
    csmProjectionMatrix3: mat4x4<f32>,
    cascadeSplits: vec4<f32>,
    viewMatrix: mat4x4<f32>,
    viewMatrixInverse: mat4x4<f32>,
    // direction: vec4<f32>,
    color: vec4<f32>,
    params1: vec4<f32>,
    params2: vec4<f32>,
};

@group(0) @binding(11) var<storage, read> lights: array<Light>;
@group(0) @binding(12) var<storage, read> lightCount: u32;






struct View {
    projectionOutputSize: vec4<f32>,
    viewPosition: vec4<f32>,
    projectionInverseMatrix: mat4x4<f32>,
    viewInverseMatrix: mat4x4<f32>,
    viewMatrix: mat4x4<f32>,
};
@group(0) @binding(13) var<storage, read> view: View;


const numCascades = 4;
const debug_cascadeColors = array<vec4<f32>, 5>(
    vec4<f32>(1.0, 0.0, 0.0, 1.0),
    vec4<f32>(0.0, 1.0, 0.0, 1.0),
    vec4<f32>(0.0, 0.0, 1.0, 1.0),
    vec4<f32>(1.0, 1.0, 0.0, 1.0),
    vec4<f32>(0.0, 0.0, 0.0, 1.0)
);
@group(0) @binding(14) var shadowSamplerComp: sampler_comparison;

@group(0) @binding(15) var<storage, read> settings: Settings;


@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    output.position = vec4(input.position, 0.0, 1.0);
    output.vUv = input.uv;
    return output;
}

const PI = 3.141592653589793;

const SPOT_LIGHT = 0;
const DIRECTIONAL_LIGHT = 1;
const POINT_LIGHT = 2;
const AREA_LIGHT = 3;

struct Surface {
    albedo: vec3<f32>,
    emissive: vec3<f32>,
    metallic: f32,
    roughness: f32,
    occlusion: f32,
    worldPosition: vec3<f32>,
    N: vec3<f32>,
    F0: vec3<f32>,
    V: vec3<f32>,
    depth: f32
};

fn reconstructWorldPosFromZ(
    coords: vec2<f32>,
    size: vec2<f32>,
    depthTexture: texture_depth_2d,
    projInverse: mat4x4<f32>,
    viewInverse: mat4x4<f32>
    ) -> vec4<f32> {
    let uv = coords.xy / size;
    var depth = textureLoad(depthTexture, vec2<i32>(floor(coords)), 0);
    let x = uv.x * 2.0 - 1.0;
    let y = (1.0 - uv.y) * 2.0 - 1.0;
    let projectedPos = vec4(x, y, depth, 1.0);
    var worldPosition = projInverse * projectedPos;
    worldPosition = vec4(worldPosition.xyz / worldPosition.w, 1.0);
    worldPosition = viewInverse * worldPosition;
    return worldPosition;
}

fn toneMapping(color: vec3f) -> vec3f {
    // Narkowicz 2015 ACES approx
    let a = 2.51; let b = 0.03; let c = 2.43; let d = 0.59; let e = 0.14;
    return clamp((color*(a*color+b)) / (color*(c*color+d)+e), vec3f(0.0), vec3f(1.0));
}

fn DistributionGGX(n: vec3f, h: vec3f, roughness: f32) -> f32 {
  let a = roughness * roughness;
  let a2 = a * a;
  let nDotH = max(dot(n, h), 0.0);
  let nDotH2 = nDotH * nDotH;
  var denom = (nDotH2 * (a2 - 1.0) + 1.0);
  denom = PI * denom * denom;
  return a2 / denom;
}

fn GeometrySchlickGGX(nDotV: f32, roughness: f32) -> f32 {
  let r = (roughness + 1.0);
  let k = (r * r) / 8.0;
  return nDotV / (nDotV * (1.0 - k) + k);
}

fn GeometrySmith(n: vec3f, v: vec3f, l: vec3f, roughness: f32) -> f32 {
  let nDotV = max(dot(n, v), 0.0);
  let nDotL = max(dot(n, l), 0.0);
  let ggx2 = GeometrySchlickGGX(nDotV, roughness);
  let ggx1 = GeometrySchlickGGX(nDotL, roughness);
  return ggx1 * ggx2;
}

fn FresnelSchlick(cosTheta: f32, f0: vec3f) -> vec3f {
  return f0 + (1.0 - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

fn FresnelSchlickRoughness(cosTheta: f32, f0: vec3f, roughness: f32) -> vec3f {
  return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

fn fixCubeHandedness(d: vec3f) -> vec3f {
    // try flipping X first; if that’s wrong, flip Z instead
    return vec3f(-d.x, d.y, d.z);
}

fn CalculateBRDF(surface: Surface, pointToLight: vec3<f32>) -> vec3<f32> {
    // cook-torrance brdf
    let L = normalize(pointToLight);
    let H = normalize(surface.V + L);
    let distance = length(pointToLight);

    let NDF = DistributionGGX(surface.N, H, surface.roughness);
    let G = GeometrySmith(surface.N, surface.V, L, surface.roughness);
    let F = FresnelSchlick(max(dot(H, surface.V), 0.0), surface.F0);

    let kD = (vec3(1.0, 1.0, 1.0) - F) * (1.0 - surface.metallic);

    let NdotL = max(dot(surface.N, L), 0.0);

    let numerator = NDF * G * F;
    let denominator = max(4.0 * max(dot(surface.N, surface.V), 0.0) * NdotL, 0.001);
    let specular = numerator / vec3(denominator, denominator, denominator);

    return (kD * surface.albedo.rgb / vec3(PI, PI, PI) + specular) * NdotL;
}

fn DirectionalLightRadiance(light: DirectionalLight, surface : Surface) -> vec3<f32> {
    return CalculateBRDF(surface, light.direction) * light.color * light.intensity;
}

fn rangeAttenuation(range : f32, distance : f32) -> f32 {
    if (range <= 0.0) {
        // Negative range means no cutoff
        return 1.0 / pow(distance, 2.0);
    }
    return clamp(1.0 - pow(distance / range, 4.0), 0.0, 1.0) / pow(distance, 2.0);
}

fn SpotLightRadiance(light : SpotLight, surface : Surface) -> vec3<f32> {
    // pointToLight is SURFACE -> LIGHT (as you already set)
    let dist = length(light.pointToLight);

    // For cone test we need LIGHT -> SURFACE
    let L_ls = normalize(-light.pointToLight);   // light -> surface
    let cd   = dot(light.direction, L_ls);       // cos(theta), 1 at center

    // Smooth falloff from edge to center: 0 at cos(angle), 1 at 1.0
    let spot = smoothstep(cos(light.angle), 1.0, cd);

    // Range attenuation as you have it
    let attenuation = rangeAttenuation(light.range, dist) * spot;

    // BRDF usually expects wi = SURFACE -> LIGHT
    let wi = -L_ls; // (surface -> light)
    let radiance = CalculateBRDF(surface, wi) * light.color * light.intensity * attenuation;
    return radiance;
}

fn PointLightRadiance(light: PointLight, surface: Surface) -> vec3<f32> {
    let dist = length(light.pointToLight);
    let wi   = normalize(light.pointToLight);        // surface -> light
    let att  = rangeAttenuation(light.range, dist);  // your smooth cutoff / r^2
    return CalculateBRDF(surface, wi) * light.color * light.intensity * att;
}

struct ShadowCSM {
    visibility: f32,
    selectedCascade: i32
};

// ---------- helpers ----------

fn selectCascade(depthValue: f32, splits: vec4<f32>) -> i32 {
    // count how many splits we have passed (0..3)
    var layer = 0;
    layer += select(0, 1, depthValue >= splits.x);
    layer += select(0, 1, depthValue >= splits.y);
    layer += select(0, 1, depthValue >= splits.z);
    return clamp(layer, 0, numCascades - 1);
}

fn csmMatrix(light: Light, idx: i32) -> mat4x4<f32> {
    if (idx == 0) { return light.csmProjectionMatrix0; }
    if (idx == 1) { return light.csmProjectionMatrix1; }
    if (idx == 2) { return light.csmProjectionMatrix2; }
    return light.csmProjectionMatrix3;
}

fn inUnitSquare(u: vec2<f32>) -> bool {
    return all(u >= vec2<f32>(0.0)) && all(u <= vec2<f32>(1.0));
}

// NDC -> UV, then remap into the 2×2 quadrant atlas inside ONE array layer.
fn worldToAtlasUVZ(worldPos: vec3<f32>, light: Light, cascadeIndex: i32) -> vec3<f32> {
    let m = csmMatrix(light, cascadeIndex);
    let p = m * vec4(worldPos, 1.0);
    let ndc = p.xyz / p.w;

    // NDC -> [0,1], with y flipped to texture space
    var uv = ndc.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);

    // Quadrant packing: [0]=BL, [1]=TL, [2]=BR, [3]=TR (matches your original logic)
    if (cascadeIndex >= 2) { uv.x += 1.0; }
    if ((cascadeIndex & 1) == 1) { uv.y += 1.0; }
    uv *= 0.5;

    return vec3<f32>(uv, ndc.z);
}

// Center tap early-accept + unrolled 3×3 PCF (fast path)
fn pcf3x3_quadrant(
    uv: vec2<f32>, z: f32, layer: i32, texel: vec2<f32>
) -> f32 {
    // Early accept: fully lit center → 1.0
    let center = textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv, layer, z);
    if (center >= 1.0) { return 1.0; }

    var sum = 0.0;
    // Row -1
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x, -texel.y), layer, z);
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(         0.0, -texel.y), layer, z);
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x, -texel.y), layer, z);
    // Row  0
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x,          0.0), layer, z);
    sum += center;
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x,          0.0), layer, z);
    // Row +1
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(-texel.x,  texel.y), layer, z);
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2(         0.0,  texel.y), layer, z);
    sum += textureSampleCompareLevel(shadowPassDepth, shadowSamplerComp, uv + vec2( texel.x,  texel.y), layer, z);

    return sum * (1.0 / 9.0);
}

// Optional: bounded dynamic radius (clamped to MAX_RADIUS to avoid explosions)
const MAX_RADIUS : i32 = 2; // up to 5×5
fn pcfBounded(
    uv: vec2<f32>, z: f32, layer: i32, texel: vec2<f32>, radius: i32
) -> f32 {
    let r = clamp(radius, 0, MAX_RADIUS);
    if (r <= 1) { return pcf3x3_quadrant(uv, z, layer, texel); }

    var sum = 0.0;
    for (var j = -r; j <=  r; j = j + 1) {
        for (var i = -r; i <=  r; i = i + 1) {
            sum += textureSampleCompareLevel(
                shadowPassDepth, shadowSamplerComp,
                uv + vec2<f32>(f32(i), f32(j)) * texel,
                layer, z
            );
        }
    }
    let taps = f32((2 * r + 1) * (2 * r + 1));
    return sum / taps;
}

// ---------- your API (drop-in) ----------

fn ShadowLayerSelection(depthValue: f32, light: Light) -> i32 {
    return selectCascade(depthValue, light.cascadeSplits);
}

fn SampleCascadeShadowMap(surface: Surface, light: Light, cascadeIndex: i32, lightIndex: u32) -> f32 {
    // Build atlas UV/Z for this cascade
    let uvz = worldToAtlasUVZ(surface.worldPosition, light, cascadeIndex);
    let uv  = uvz.xy;
    let z   = uvz.z;

    // Outside clip or outside atlas -> lit
    if (z <= 0.0 || z >= 1.0 || !inUnitSquare(uv)) {
        return 1.0;
    }

    // One textureDimensions() per pixel (ideally pass texel size from CPU)
    let texDim = vec2<f32>(textureDimensions(shadowPassDepth));
    let texel  = 1.0 / texDim;

    // Use fast 3×3 when radius <= 1, else bounded loop (max 5×5)
    let radius = i32(settings.pcfResolution); // interpret as radius
    if (radius <= 1) {
        return pcf3x3_quadrant(uv, z, i32(light.params1.w), texel);
    } else {
        return pcfBounded(uv, z, i32(light.params1.w), texel, radius);
    }
}

fn lerp(k0: f32, k1: f32, t: f32) -> f32 {
    return k0 + t * (k1 - k0);
}

fn CalculateShadowCSM(surface: Surface, light: Light, lightIndex: u32) -> ShadowCSM {
    var out: ShadowCSM;

    // View-space depth for cascade selection
    let fragPosViewSpace = view.viewMatrix * vec4f(surface.worldPosition, 1.0);
    let depthValue  = abs(fragPosViewSpace.z);

    // Early accept: beyond last split, no shadow work
    let lastSplit = light.cascadeSplits[numCascades - 1];
    if (depthValue > lastSplit) {
        out.visibility = 1.0;
        out.selectedCascade = numCascades - 1;
        return out;
    }

    // Pick cascade (branchless)
    let selectedCascade = ShadowLayerSelection(depthValue, light);
    out.selectedCascade = selectedCascade;

    // Primary cascade
    var visibility = SampleCascadeShadowMap(surface, light, selectedCascade, lightIndex);

    // Blend near the split to hide seams
    let blendThreshold   = settings.blendThreshold;
    let nextSplit  = light.cascadeSplits[selectedCascade];

    var splitSize = nextSplit;
    if (selectedCascade > 0) { splitSize = nextSplit - light.cascadeSplits[selectedCascade - 1]; }

    let fadeFactor = (nextSplit - depthValue) / max(splitSize, 1e-6);

    if (fadeFactor <= blendThreshold && selectedCascade != numCascades - 1) {
        let nextSplitVisibility = SampleCascadeShadowMap(surface, light, selectedCascade + 1, lightIndex);
        let lerpAmount = smoothstep(0.0, blendThreshold, fadeFactor);
        visibility = lerp(nextSplitVisibility, visibility, lerpAmount);

        if (u32(settings.viewBlendThreshold) == 1u) {
            visibility *= fadeFactor; // debug view
        }
    }

    out.visibility = clamp(visibility, 0.0, 1.0);
    return out;
}


// NDC -> UV, then remap into the 2×2 quadrant atlas inside ONE array layer.
fn worldToAtlasUVZSpot(worldPos: vec3<f32>, light: Light, cascadeIndex: i32) -> vec3<f32> {
    let m = light.csmProjectionMatrix0;
    let p = m * vec4(worldPos, 1.0);
    let ndc = p.xyz / p.w;

    // NDC -> [0,1], with y flipped to texture space
    var uv = ndc.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);

    return vec3<f32>(uv, ndc.z);
}

fn SampleCascadeShadowMapSpot(surface: Surface, light: Light, cascadeIndex: i32, lightIndex: u32) -> f32 {
    // Build atlas UV/Z for this cascade
    let uvz = worldToAtlasUVZSpot(surface.worldPosition, light, cascadeIndex);
    let uv  = uvz.xy;
    let z   = uvz.z;

    // Outside clip or outside atlas -> lit
    if (z <= 0.0 || z >= 1.0 || !inUnitSquare(uv)) {
        return 1.0;
    }

    // One textureDimensions() per pixel (ideally pass texel size from CPU)
    let texDim = vec2<f32>(textureDimensions(shadowPassDepth));
    let texel  = 1.0 / texDim;

    // Use fast 3×3 when radius <= 1, else bounded loop (max 5×5)
    let radius = i32(settings.pcfResolution); // interpret as radius
    if (radius <= 1) {
        return pcf3x3_quadrant(uv, z, i32(light.params1.w), texel);
    } else {
        return pcfBounded(uv, z, i32(light.params1.w), texel, radius);
    }
}

fn CalculateShadowCSMSpot(surface: Surface, light: Light, lightIndex: u32) -> ShadowCSM {
    var out: ShadowCSM;

    // View-space depth for cascade selection
    let fragPosViewSpace = view.viewMatrix * vec4f(surface.worldPosition, 1.0);
    let depthValue  = abs(fragPosViewSpace.z);

    // Pick cascade (branchless)
    let selectedCascade = 0;
    out.selectedCascade = selectedCascade;

    // Primary cascade
    let visibility = SampleCascadeShadowMapSpot(surface, light, selectedCascade, lightIndex);

    out.visibility = clamp(visibility, 0.0, 1.0);
    return out;
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
    // Load depth once
    let pix   = vec2<i32>(floor(input.position.xy));
    let depth = textureLoad(depthTexture, pix, 0);

    // Build NDC + view/world rays (same as before)
    let ndc = vec3<f32>(
        (input.position.x / view.projectionOutputSize.x) * 2.0 - 1.0,
        (input.position.y / view.projectionOutputSize.y) * 2.0 - 1.0,
        1.0
    );
    let viewRay4 = view.projectionInverseMatrix * vec4(ndc, 1.0);
    var viewRay  = normalize(viewRay4.xyz / viewRay4.w);
    viewRay.y   *= -1.0;
    var worldRay = normalize((view.viewInverseMatrix * vec4(viewRay, 0.0)).xyz);

    // ---- compute derivatives BEFORE any divergent branch ----
    let uv = input.vUv;
    let dUVdx = dpdx(uv);
    let dUVdy = dpdy(uv);

    // For cubemap LOD: take grads of the direction (works well in practice)
    let dWRdx = dpdx(worldRay);
    let dWRdy = dpdy(worldRay);

    // Early sky-out WITH explicit grads (safe mip selection)
    if (depth >= 0.9999999) {
        var sky = textureSampleGrad(skyboxTexture, textureSampler, worldRay, dWRdx, dWRdy).rgb;
        sky = toneMapping(sky);
        sky = pow(sky, vec3f(1.0 / 2.2));  // omit if writing to *-srgb
        return vec4f(sky, 1.0);
    }

    // Reconstruct world pos (consider a variant that takes 'depth' to avoid re-read inside)
    let worldPosition = reconstructWorldPosFromZ(
        input.position.xy,
        view.projectionOutputSize.xy,
        depthTexture,
        view.projectionInverseMatrix,
        view.viewInverseMatrix
    );

    // G-buffer samples now use explicit-grad
    let albedo = textureSampleGrad(albedoTexture, textureSampler, uv, dUVdx, dUVdy);
    let normal = textureSampleGrad(normalTexture, textureSampler, uv, dUVdx, dUVdy);
    let ermo   = textureSampleGrad(ermoTexture,   textureSampler, uv, dUVdx, dUVdy);

    // ... (your Surface build as-is)
    var surface: Surface;
    surface.depth          = depth;
    surface.albedo         = albedo.rgb;
    surface.roughness      = clamp(albedo.a, 0.0, 0.99);
    surface.metallic       = normal.a;
    surface.emissive       = ermo.rgb;
    surface.occlusion      = ermo.a;
    surface.worldPosition  = worldPosition.xyz;
    surface.N              = normalize(normal.rgb);
    surface.F0             = mix(vec3(0.04), surface.albedo.rgb, vec3(surface.metallic));
    surface.V              = normalize(view.viewPosition.xyz - surface.worldPosition);
    surface.occlusion      = 1.0;

    let n = surface.N;
    let v = surface.V;
    let r = reflect(-v, n);

    var lo = vec3f(0.0);
    var selectedCascade = 0;

    for (var i = 0u; i < lightCount; i++) {
        let light = lights[i];
        let lightType = u32(light.color.a);

        if (lightType == DIRECTIONAL_LIGHT) {
            var directionalLight: DirectionalLight;
            directionalLight.direction = normalize((light.viewMatrixInverse * vec4(0.0, 0.0, 1.0, 0.0)).xyz);
            // directionalLight.direction = light.direction.xyz;
            directionalLight.color = light.color.rgb;
            directionalLight.intensity = light.params1.x;

            let castShadows = light.params1.z > 0.5;
            var shadow = 1.0;
            if (castShadows) {
                let shadowCSM = CalculateShadowCSM(surface, light, i);
                shadow = shadowCSM.visibility;
                selectedCascade = shadowCSM.selectedCascade;
            }

            // lo += shadow * DirectionalLightRadiance(directionalLight, surface) * radiance;
            lo += shadow * DirectionalLightRadiance(directionalLight, surface);
        }

        else if (lightType == SPOT_LIGHT) {
            var spotLight: SpotLight;
            
            spotLight.pointToLight = light.position.xyz - surface.worldPosition;
            spotLight.color = light.color.rgb;
            spotLight.intensity = light.params1.r;
            spotLight.range = light.params1.g;
            spotLight.direction = normalize((light.viewMatrixInverse * vec4(0.0, 0.0, -1.0, 0.0)).xyz);
            // spotLight.direction = light.direction.xyz;
            spotLight.angle = light.params2.w;

            if (distance(light.position.xyz, surface.worldPosition) > spotLight.range) {
                continue;
            }

            let castShadows = light.params1.z > 0.5;
            var shadow = 1.0;
            if (castShadows) {
                let shadowCSM = CalculateShadowCSMSpot(surface, light, i);
                shadow = shadowCSM.visibility;
                selectedCascade = shadowCSM.selectedCascade;
                // shadow = SampleSpotShadowMap(surface, light); // <— single 2D map on this layer

            }

            lo += shadow * SpotLightRadiance(spotLight, surface);
        }

        else if (lightType == POINT_LIGHT) {
            var p: PointLight;
            p.pointToLight = light.position.xyz - surface.worldPosition;
            p.color        = light.color.rgb;
            p.intensity    = light.params1.x;
            p.range        = light.params1.y;

            // optional hard range cut
            if (length(p.pointToLight) > p.range) {
                continue;
            }

            var shadow = 1.0;
            let castShadows = light.params1.z > 0.5;
            // if (castShadows) {
            //     // see section 2 for a cubemap version
            //     shadow = SamplePointShadow(surface, light, i);  // implement below
            // }

            lo += shadow * PointLightRadiance(p, surface);
        }
    }

    let f = FresnelSchlickRoughness(max(dot(n, v), 0.00001), surface.F0, surface.roughness);
    let kS = f;
    var kD = vec3f(1.0) - kS;
    kD *= 1.0 - surface.metallic;

    let irradiance = textureSampleLevel(skyboxIrradianceTexture, textureSampler, fixCubeHandedness(n), 0.0).rgb;
    let diffuse = irradiance * surface.albedo.xyz;

    const MAX_REFLECTION_LOD = 4.0;
    let prefilteredColor = textureSampleLevel(skyboxPrefilterTexture, textureSampler, fixCubeHandedness(r), surface.roughness * MAX_REFLECTION_LOD).rgb;
    let brdf = textureSampleLevel(skyboxBRDFLUT, brdfSampler, vec2f(max(dot(n, v), 0.0), surface.roughness), 1.0).rg;
    let specular = prefilteredColor * (f * brdf.x + brdf.y);

    let ambient = (kD * diffuse + specular) * surface.occlusion;

    var color = ambient + lo + surface.emissive;

    // if (u32(settings.debugShadowCascades) == 0) {
    //     color += debug_cascadeColors[selectedCascade].rgb * 0.05;
    // }

    color = toneMapping(color);
    color = pow(color, vec3f(1.0 / 2.2));

    return vec4f(color, 1.0);
}