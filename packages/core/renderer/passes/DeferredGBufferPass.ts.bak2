import { Camera } from "../../components/Camera";
import { RendererContext } from "../RendererContext";
import { RenderPass, ResourcePool } from "../RenderGraph";
import { SkinnedMesh } from "../../components/SkinnedMesh";
import { PassParams } from "../RenderingPipeline";
import { Renderer } from "../Renderer";
import { DynamicBufferMemoryAllocator } from "../MemoryAllocator";
import { Shader } from "../Shader";
import { Renderable } from "./PrepareSceneData";

export class DeferredGBufferPass extends RenderPass {
    public name: string = "DeferredGBufferPass";
    private modelMatrixBuffer: DynamicBufferMemoryAllocator;

    public async init(resources: ResourcePool) {
        this.modelMatrixBuffer = new DynamicBufferMemoryAllocator(16 * 4 * 1000);
        this.initialized = true;
    }

    private BindGlobalBuffers(shader: Shader, resources: ResourcePool) {
        // @group(1) @binding(0) var<storage, read> Frame: FrameBuffer;
        shader.SetBuffer("Frame", resources.getResource(PassParams.FrameBuffer));
        shader.SetBuffer("Materials", resources.getResource(PassParams.MaterialBuffer).getBuffer());
        shader.SetBuffer("Models", resources.getResource(PassParams.ModelBuffer).getBuffer());
        shader.SetBuffer("Instance", resources.getResource(PassParams.InstanceBuffer).getBuffer());
    }

    public async preFrame(resources: ResourcePool) {
        this.drawCommands.length = 0;
        if (!this.initialized) return;

        // Get global renderables from PrepareSceneData
        const renderables = resources.getResource(PassParams.Renderables) as Renderable[];
        if (renderables.length === 0) return;

        Renderer.info.visibleObjects = renderables.length;

        for (const renderable of renderables) {
            this.BindGlobalBuffers(renderable.shader, resources);

            if (renderable.mesh instanceof SkinnedMesh) {
                renderable.shader.SetBuffer("boneMatrices", renderable.mesh.GetBoneMatricesBuffer());
            }

            this.drawCommands.push({
                geometry: renderable.geometry,
                shader: renderable.shader,
                instanceCount: renderable.instanceCount,
                firstInstance: renderable.firstInstance
            });

            // Debug info
            const position = renderable.geometry.attributes.get("position");
            Renderer.info.vertexCount += (position.array.length / 3) * renderable.instanceCount;
            Renderer.info.triangleCount += (renderable.geometry.index ? renderable.geometry.index.array.length / 3 : position.array.length / 3) * renderable.instanceCount;
        }
    }

    public async execute(resources: ResourcePool) {
        if (!this.initialized) return;
        if (this.drawCommands.length === 0) return;

        const inputCamera = Camera.mainCamera;
        if (!inputCamera) throw Error(`No inputs passed to ${this.name}`);
        const backgroundColor = inputCamera.backgroundColor;

        const inputGBufferAlbedo = resources.getResource(PassParams.GBufferAlbedo);
        const inputGBufferNormal = resources.getResource(PassParams.GBufferNormal);
        const inputGBufferERMO = resources.getResource(PassParams.GBufferERMO);
        const inputGBufferDepth = resources.getResource(PassParams.GBufferDepth);

        RendererContext.BeginRenderPass(this.name,
            [
                {target: inputGBufferAlbedo, clear: false, color: backgroundColor},
                {target: inputGBufferNormal, clear: false, color: backgroundColor},
                {target: inputGBufferERMO, clear: false, color: backgroundColor},
            ],
            {target: inputGBufferDepth, clear: false}
        , true);

        for (const draw of this.drawCommands) RendererContext.DrawGeometry(draw.geometry, draw.shader, draw.instanceCount, draw.firstInstance);

        resources.setResource(PassParams.GBufferDepth, inputGBufferDepth);
        resources.setResource(PassParams.GBufferAlbedo, inputGBufferAlbedo);
        resources.setResource(PassParams.GBufferNormal, inputGBufferNormal);
        resources.setResource(PassParams.GBufferERMO, inputGBufferERMO);

        RendererContext.EndRenderPass();
    }
}