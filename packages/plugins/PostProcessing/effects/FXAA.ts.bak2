import {
	Geometry,
	Mathf,
	GPU
} from "@trident/core";
import { Debugger } from "@trident/plugins/Debugger";
import { UIButtonStat, UIDropdownStat, UIFolder, UISliderStat } from "@trident/plugins/ui/UIStats";

import { DataBackedBuffer } from "@trident/plugins/DataBackedBuffer";

export class PostProcessingFXAA extends GPU.RenderPass {
	public name: string = "PostProcessingFXAA";
	private shader: GPU.Shader;
	private quadGeometry: Geometry;

	private renderTarget: GPU.RenderTexture;

	constructor() {
		super({
			inputs: [
				GPU.PassParams.LightingPassOutput,
			]
		});
	}

	public async init() {
		const code = `
		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) normal : vec3<f32>,
			@location(2) uv : vec2<f32>,
		};

		struct VertexOutput {
			@builtin(position) position : vec4<f32>,
			@location(0) vUv : vec2<f32>,
		};

		@vertex fn vertexMain(input: VertexInput) -> VertexOutput {
			var output: VertexOutput;
			output.position = vec4(input.position, 1.0);
			output.vUv = input.uv;
			// output.vUv = input.position.xy * vec2(0.5, -0.5) + 0.5;
			return output;
		}

		// FXAA (WGSL) â€” runtime-configurable version (no preprocessor)

		// --- bindings ---------------------------------------------------------------
		// group(0), binding(0): color input
		@group(0) @binding(0) var u_texture : texture_2d<f32>;
		@group(0) @binding(1) var u_sampler : sampler;

		// all options + constants that used to be macros/defines
		struct FxaaUniforms {
			// feature toggles (use 0 = false, 1 = true)
			FXAA_ENABLE            : f32,
			FXAA_LUMA              : f32,
			FXAA_GREEN_AS_LUMA     : f32,

			// core uniforms
			// RcpFrame                       : vec2f,  // 1/width, 1/height
			RcpFrameW                       : f32,  // 1/width, 1/height
			RcpFrameH                       : f32,
			u_fxaaQualitySubpix            : f32,
			u_fxaaQualityEdgeThreshold     : f32,
			u_fxaaQualityEdgeThresholdMin  : f32,

			// quality preset data
			FXAA_QUALITY_PS  : f32,  // how many taps blocks are enabled (used like the old #if > N)

			// the P0..P12 step table (fill only what you use for your preset)
			FXAA_QUALITY_P0  : f32,
			FXAA_QUALITY_P1  : f32,
			FXAA_QUALITY_P2  : f32,
			FXAA_QUALITY_P3  : f32,
			FXAA_QUALITY_P4  : f32,
			FXAA_QUALITY_P5  : f32,
			FXAA_QUALITY_P6  : f32,
			FXAA_QUALITY_P7  : f32,
			FXAA_QUALITY_P8  : f32,
			FXAA_QUALITY_P9  : f32,
			FXAA_QUALITY_P10 : f32,
			FXAA_QUALITY_P11 : f32,
			FXAA_QUALITY_P12 : f32,

			pad : vec2<f32>,
		};
		@group(0) @binding(2) var<uniform> fxaa : FxaaUniforms;

		// --- helpers ----------------------------------------------------------------
		fn texture2D(tex: texture_2d<f32>, smp: sampler, uv: vec2f) -> vec4f {
			return textureSampleLevel(tex, smp, uv, 0);
		}

		fn FxaaLuma(rgba: vec4f, greenAsLuma: bool) -> f32 {
			// match GLSL: when GREEN_AS_LUMA==0, alpha holds perceptual luma
			return select(rgba.w, rgba.y, greenAsLuma);
		}

		// --- main FXAA pixel shader -------------------------------------------------
		fn FxaaPixelShader(
			// {xy} = center of pixel
			pos: vec2f,
			// color texture + sampler
			tex: texture_2d<f32>,
			smp: sampler,
			// uniforms (formerly compile-time)
			fxaaQualityRcpFrame: vec2f,
			fxaaQualitySubpix: f32,
			fxaaQualityEdgeThreshold: f32,
			fxaaQualityEdgeThresholdMin: f32,
			// runtime "defines"
			FXAA_GREEN_AS_LUMA: bool,
			FXAA_QUALITY_PS: i32,
			FXAA_QUALITY_P0: f32,
			FXAA_QUALITY_P1: f32,
			FXAA_QUALITY_P2: f32,
			FXAA_QUALITY_P3: f32,
			FXAA_QUALITY_P4: f32,
			FXAA_QUALITY_P5: f32,
			FXAA_QUALITY_P6: f32,
			FXAA_QUALITY_P7: f32,
			FXAA_QUALITY_P8: f32,
			FXAA_QUALITY_P9: f32,
			FXAA_QUALITY_P10: f32,
			FXAA_QUALITY_P11: f32,
			FXAA_QUALITY_P12: f32
		) -> vec4f {
			var posM = pos;
			let rgbyM = texture2D(tex, smp, posM);
			let lumaM = FxaaLuma(rgbyM, FXAA_GREEN_AS_LUMA);

			var lumaS = FxaaLuma(texture2D(tex, smp, posM + (vec2f( 0.0,  1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			var lumaE = FxaaLuma(texture2D(tex, smp, posM + (vec2f( 1.0,  0.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			var lumaN = FxaaLuma(texture2D(tex, smp, posM + (vec2f( 0.0, -1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			var lumaW = FxaaLuma(texture2D(tex, smp, posM + (vec2f(-1.0,  0.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);

			let maxSM = max(lumaS, lumaM);
			let minSM = min(lumaS, lumaM);
			let maxESM = max(lumaE, maxSM);
			let minESM = min(lumaE, minSM);
			let maxWN = max(lumaN, lumaW);
			let minWN = min(lumaN, lumaW);
			let rangeMax = max(maxWN, maxESM);
			let rangeMin = min(minWN, minESM);
			let rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
			let range = rangeMax - rangeMin;
			let rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
			let earlyExit = range < rangeMaxClamped;

			if (earlyExit) {
				return rgbyM;
			}

			let lumaNW = FxaaLuma(texture2D(tex, smp, posM + (vec2f(-1.0, -1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			let lumaSE = FxaaLuma(texture2D(tex, smp, posM + (vec2f( 1.0,  1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			let lumaNE = FxaaLuma(texture2D(tex, smp, posM + (vec2f( 1.0, -1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);
			let lumaSW = FxaaLuma(texture2D(tex, smp, posM + (vec2f(-1.0,  1.0) * fxaaQualityRcpFrame.xy)), FXAA_GREEN_AS_LUMA);

			let lumaNS = lumaN + lumaS;
			let lumaWE = lumaW + lumaE;
			let subpixRcpRange = 1.0 / range;
			let subpixNSWE = lumaNS + lumaWE;
			let edgeHorz1 = (-2.0 * lumaM) + lumaNS;
			let edgeVert1 = (-2.0 * lumaM) + lumaWE;

			let lumaNESE = lumaNE + lumaSE;
			let lumaNWNE = lumaNW + lumaNE;
			let edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
			let edgeVert2 = (-2.0 * lumaN) + lumaNWNE;

			let lumaNWSW = lumaNW + lumaSW;
			let lumaSWSE = lumaSW + lumaSE;
			let edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
			let edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
			let edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
			let edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
			let edgeHorz = abs(edgeHorz3) + edgeHorz4;
			let edgeVert = abs(edgeVert3) + edgeVert4;

			let subpixNWSWNESE = lumaNWSW + lumaNESE;
			var lengthSign = fxaaQualityRcpFrame.x;
			let horzSpan = edgeHorz >= edgeVert;
			let subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;

			if (!horzSpan) { lumaN = lumaW; }
			if (!horzSpan) { lumaS = lumaE; }
			if ( horzSpan) { lengthSign = fxaaQualityRcpFrame.y; }
			let subpixB = (subpixA * (1.0 / 12.0)) - lumaM;

			let gradientN = lumaN - lumaM;
			let gradientS = lumaS - lumaM;
			var lumaNN = lumaN + lumaM;
			var lumaSS = lumaS + lumaM;
			let pairN = abs(gradientN) >= abs(gradientS);
			let gradient = max(abs(gradientN), abs(gradientS));
			if (pairN) { lengthSign = -lengthSign; }
			let subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);

			var posB = posM;
			var offNP = vec2f(0.0, 0.0);
			if (!horzSpan) { offNP.x = 0.0; offNP.y = fxaaQualityRcpFrame.y; }
			if ( horzSpan) { offNP.x = fxaaQualityRcpFrame.x; offNP.y = 0.0; }
			if (!horzSpan) { posB.x += lengthSign * 0.5; }
			if ( horzSpan) { posB.y += lengthSign * 0.5; }

			var posN = posB - offNP * FXAA_QUALITY_P0;
			var posP = posB + offNP * FXAA_QUALITY_P0;

			let subpixD = ((-2.0) * subpixC) + 3.0;
			var lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA);
			let subpixE = subpixC * subpixC;
			var lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA);

			if (!pairN) { lumaNN = lumaSS; }
			let gradientScaled = gradient * (1.0 / 4.0);
			let lumaMM = lumaM - lumaNN * 0.5;
			let subpixF = subpixD * subpixE;
			let lumaMLTZero = lumaMM < 0.0;

			lumaEndN -= lumaNN * 0.5;
			lumaEndP -= lumaNN * 0.5;
			var doneN = abs(lumaEndN) >= gradientScaled;
			var doneP = abs(lumaEndP) >= gradientScaled;
			if (!doneN) { posN -= offNP * FXAA_QUALITY_P1; }
			var doneNP = (!doneN) || (!doneP);
			if (!doneP) { posP += offNP * FXAA_QUALITY_P1; }

			if (doneNP) {
				if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
				if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
				if (!doneN) { lumaEndN -= lumaNN * 0.5; }
				if (!doneP) { lumaEndP -= lumaNN * 0.5; }
				doneN = abs(lumaEndN) >= gradientScaled;
				doneP = abs(lumaEndP) >= gradientScaled;
				if (!doneN) { posN -= offNP * FXAA_QUALITY_P2; }
				doneNP = (!doneN) || (!doneP);
				if (!doneP) { posP += offNP * FXAA_QUALITY_P2; }

				if (FXAA_QUALITY_PS > 3) {
					if (doneNP) {
						if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
						if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
						if (!doneN) { lumaEndN -= lumaNN * 0.5; }
						if (!doneP) { lumaEndP -= lumaNN * 0.5; }
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if (!doneN) { posN -= offNP * FXAA_QUALITY_P3; }
						doneNP = (!doneN) || (!doneP);
						if (!doneP) { posP += offNP * FXAA_QUALITY_P3; }

						if (FXAA_QUALITY_PS > 4) {
							if (doneNP) {
								if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
								if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
								if (!doneN) { lumaEndN -= lumaNN * 0.5; }
								if (!doneP) { lumaEndP -= lumaNN * 0.5; }
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if (!doneN) { posN -= offNP * FXAA_QUALITY_P4; }
								doneNP = (!doneN) || (!doneP);
								if (!doneP) { posP += offNP * FXAA_QUALITY_P4; }

								if (FXAA_QUALITY_PS > 5) {
									if (doneNP) {
										if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
										if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
										if (!doneN) { lumaEndN -= lumaNN * 0.5; }
										if (!doneP) { lumaEndP -= lumaNN * 0.5; }
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if (!doneN) { posN -= offNP * FXAA_QUALITY_P5; }
										doneNP = (!doneN) || (!doneP);
										if (!doneP) { posP += offNP * FXAA_QUALITY_P5; }

										if (FXAA_QUALITY_PS > 6) {
											if (doneNP) {
												if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
												if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
												if (!doneN) { lumaEndN -= lumaNN * 0.5; }
												if (!doneP) { lumaEndP -= lumaNN * 0.5; }
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if (!doneN) { posN -= offNP * FXAA_QUALITY_P6; }
												doneNP = (!doneN) || (!doneP);
												if (!doneP) { posP += offNP * FXAA_QUALITY_P6; }

												if (FXAA_QUALITY_PS > 7) {
													if (doneNP) {
														if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
														if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
														if (!doneN) { lumaEndN -= lumaNN * 0.5; }
														if (!doneP) { lumaEndP -= lumaNN * 0.5; }
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if (!doneN) { posN -= offNP * FXAA_QUALITY_P7; }
														doneNP = (!doneN) || (!doneP);
														if (!doneP) { posP += offNP * FXAA_QUALITY_P7; }

														if (FXAA_QUALITY_PS > 8) {
															if (doneNP) {
																if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
																if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
																if (!doneN) { lumaEndN -= lumaNN * 0.5; }
																if (!doneP) { lumaEndP -= lumaNN * 0.5; }
																doneN = abs(lumaEndN) >= gradientScaled;
																doneP = abs(lumaEndP) >= gradientScaled;
																if (!doneN) { posN -= offNP * FXAA_QUALITY_P8; }
																doneNP = (!doneN) || (!doneP);
																if (!doneP) { posP += offNP * FXAA_QUALITY_P8; }

																if (FXAA_QUALITY_PS > 9) {
																	if (doneNP) {
																		if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
																		if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
																		if (!doneN) { lumaEndN -= lumaNN * 0.5; }
																		if (!doneP) { lumaEndP -= lumaNN * 0.5; }
																		doneN = abs(lumaEndN) >= gradientScaled;
																		doneP = abs(lumaEndP) >= gradientScaled;
																		if (!doneN) { posN -= offNP * FXAA_QUALITY_P9; }
																		doneNP = (!doneN) || (!doneP);
																		if (!doneP) { posP += offNP * FXAA_QUALITY_P9; }

																		if (FXAA_QUALITY_PS > 10) {
																			if (doneNP) {
																				if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
																				if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
																				if (!doneN) { lumaEndN -= lumaNN * 0.5; }
																				if (!doneP) { lumaEndP -= lumaNN * 0.5; }
																				doneN = abs(lumaEndN) >= gradientScaled;
																				doneP = abs(lumaEndP) >= gradientScaled;
																				if (!doneN) { posN -= offNP * FXAA_QUALITY_P10; }
																				doneNP = (!doneN) || (!doneP);
																				if (!doneP) { posP += offNP * FXAA_QUALITY_P10; }

																				if (FXAA_QUALITY_PS > 11) {
																					if (doneNP) {
																						if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
																						if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
																						if (!doneN) { lumaEndN -= lumaNN * 0.5; }
																						if (!doneP) { lumaEndP -= lumaNN * 0.5; }
																						doneN = abs(lumaEndN) >= gradientScaled;
																						doneP = abs(lumaEndP) >= gradientScaled;
																						if (!doneN) { posN -= offNP * FXAA_QUALITY_P11; }
																						doneNP = (!doneN) || (!doneP);
																						if (!doneP) { posP += offNP * FXAA_QUALITY_P11; }

																						if (FXAA_QUALITY_PS > 12) {
																							if (doneNP) {
																								if (!doneN) { lumaEndN = FxaaLuma(texture2D(tex, smp, posN), FXAA_GREEN_AS_LUMA); }
																								if (!doneP) { lumaEndP = FxaaLuma(texture2D(tex, smp, posP), FXAA_GREEN_AS_LUMA); }
																								if (!doneN) { lumaEndN -= lumaNN * 0.5; }
																								if (!doneP) { lumaEndP -= lumaNN * 0.5; }
																								doneN = abs(lumaEndN) >= gradientScaled;
																								doneP = abs(lumaEndP) >= gradientScaled;
																								if (!doneN) { posN -= offNP * FXAA_QUALITY_P12; }
																								doneNP = (!doneN) || (!doneP);
																								if (!doneP) { posP += offNP * FXAA_QUALITY_P12; }
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}

			var dstN = posM.x - posN.x;
			var dstP = posP.x - posM.x;
			if (!horzSpan) { dstN = posM.y - posN.y; }
			if (!horzSpan) { dstP = posP.y - posM.y; }

			let goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
			let spanLength = (dstP + dstN);
			let goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
			let spanLengthRcp = 1.0 / spanLength;

			let directionN = dstN < dstP;
			let dst = min(dstN, dstP);
			let goodSpan = select(goodSpanP, goodSpanN, directionN);
			let subpixG = subpixF * subpixF;
			let pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
			let subpixH = subpixG * fxaaQualitySubpix;

			let pixelOffsetGood = select(0.0, pixelOffset, goodSpan);
			let pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
			if (!horzSpan) { posM.x += pixelOffsetSubpix * lengthSign; }
			if ( horzSpan) { posM.y += pixelOffsetSubpix * lengthSign; }
			return vec4f(texture2D(tex, smp, posM).xyz, lumaM);
		}

		// --- fragment entry ---------------------------------------------------------
		@fragment
		fn main(@location(0) uv : vec2f) -> @location(0) vec4f {
			var do_luma   = u32(fxaa.FXAA_LUMA)          != 0u;
			var do_fxaa   = u32(fxaa.FXAA_ENABLE)        != 0u;
			var greenLum  = u32(fxaa.FXAA_GREEN_AS_LUMA) != 0u;

			// do_luma = false;
			// do_fxaa = true;
			// greenLum = false;

			// return vec4f(fxaa.u_fxaaQualitySubpix);


			if (do_luma) {
				let c = texture2D(u_texture, u_sampler, uv);
				if (greenLum) {
					return vec4f(c.yyy, 1.0); // green as luma
				} else {
					return vec4f(c.www, 1.0); // alpha contains luma
				}
			} else if (do_fxaa) {
				return FxaaPixelShader(
					uv,
					u_texture, u_sampler,
					vec2f(fxaa.RcpFrameW, fxaa.RcpFrameH),
					fxaa.u_fxaaQualitySubpix,
					fxaa.u_fxaaQualityEdgeThreshold,
					fxaa.u_fxaaQualityEdgeThresholdMin,
					greenLum,
					i32(fxaa.FXAA_QUALITY_PS),
					fxaa.FXAA_QUALITY_P0,
					fxaa.FXAA_QUALITY_P1,
					fxaa.FXAA_QUALITY_P2,
					fxaa.FXAA_QUALITY_P3,
					fxaa.FXAA_QUALITY_P4,
					fxaa.FXAA_QUALITY_P5,
					fxaa.FXAA_QUALITY_P6,
					fxaa.FXAA_QUALITY_P7,
					fxaa.FXAA_QUALITY_P8,
					fxaa.FXAA_QUALITY_P9,
					fxaa.FXAA_QUALITY_P10,
					fxaa.FXAA_QUALITY_P11,
					fxaa.FXAA_QUALITY_P12
				);
			} else {
				return vec4f(texture2D(u_texture, u_sampler, uv).rgb, 1.0);
			}

		}
		`

		this.shader = await GPU.Shader.Create({
			code: code,
			colorOutputs: [{ format: GPU.Renderer.SwapChainFormat }],
			attributes: {
				position: { location: 0, size: 3, type: "vec3" },
				normal: { location: 1, size: 3, type: "vec3" },
				uv: { location: 2, size: 2, type: "vec2" }
			},
			uniforms: {
				u_texture: { group: 0, binding: 0, type: "texture" },
				u_sampler: { group: 0, binding: 1, type: "sampler" },
				fxaa: { group: 0, binding: 2, type: "uniform" },
			}
		});
		this.quadGeometry = Geometry.Plane();


		const presets =
			[
				{
					FXAA_QUALITY_PS: 3,
					FXAA_QUALITY_P0: 1.5,
					FXAA_QUALITY_P1: 3.0,
					FXAA_QUALITY_P2: 12.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 4,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 3.0,
					FXAA_QUALITY_P3: 12.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 5,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 4.0,
					FXAA_QUALITY_P4: 12.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 6,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 4.0,
					FXAA_QUALITY_P5: 12.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 7,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 4.0,
					FXAA_QUALITY_P6: 12.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 8,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 4.0,
					FXAA_QUALITY_P7: 12.0,
				},

				/*============================================================================
									FXAA QUALITY - LOW DITHER PRESETS
				============================================================================*/
				{
					FXAA_QUALITY_PS: 3,
					FXAA_QUALITY_P0: 1.5,
					FXAA_QUALITY_P1: 2.0,
					FXAA_QUALITY_P2: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 4,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 5,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 6,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 7,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 3.0,
					FXAA_QUALITY_P6: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 8,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 4.0,
					FXAA_QUALITY_P7: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 9,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 2.0,
					FXAA_QUALITY_P7: 4.0,
					FXAA_QUALITY_P8: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 10,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 2.0,
					FXAA_QUALITY_P7: 2.0,
					FXAA_QUALITY_P8: 4.0,
					FXAA_QUALITY_P9: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 11,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 2.0,
					FXAA_QUALITY_P7: 2.0,
					FXAA_QUALITY_P8: 2.0,
					FXAA_QUALITY_P9: 4.0,
					FXAA_QUALITY_P10: 8.0,
				},
				/*--------------------------------------------------------------------------*/
				{
					FXAA_QUALITY_PS: 12,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.5,
					FXAA_QUALITY_P2: 2.0,
					FXAA_QUALITY_P3: 2.0,
					FXAA_QUALITY_P4: 2.0,
					FXAA_QUALITY_P5: 2.0,
					FXAA_QUALITY_P6: 2.0,
					FXAA_QUALITY_P7: 2.0,
					FXAA_QUALITY_P8: 2.0,
					FXAA_QUALITY_P9: 2.0,
					FXAA_QUALITY_P10: 4.0,
					FXAA_QUALITY_P11: 8.0,
				},

				/*============================================================================
									FXAA QUALITY - EXTREME QUALITY
				============================================================================*/
				{
					FXAA_QUALITY_PS: 12,
					FXAA_QUALITY_P0: 1.0,
					FXAA_QUALITY_P1: 1.0,
					FXAA_QUALITY_P2: 1.0,
					FXAA_QUALITY_P3: 1.0,
					FXAA_QUALITY_P4: 1.0,
					FXAA_QUALITY_P5: 1.5,
					FXAA_QUALITY_P6: 2.0,
					FXAA_QUALITY_P7: 2.0,
					FXAA_QUALITY_P8: 2.0,
					FXAA_QUALITY_P9: 2.0,
					FXAA_QUALITY_P10: 4.0,
					FXAA_QUALITY_P11: 8.0,
				}
			];

		interface FXAASettings {
			FXAA_ENABLE: [number],
			FXAA_LUMA: [number],
			FXAA_GREEN_AS_LUMA: [number],

			// 	// core uniforms
			// RcpFrame: [number, number],
			RcpFrameW: [number],
			RcpFrameH: [number],
			u_fxaaQualitySubpix: [number],
			u_fxaaQualityEdgeThreshold: [number],
			u_fxaaQualityEdgeThresholdMin: [number],

			// 	// quality preset data
			FXAA_QUALITY_PS: [number],

			// 	// the P0..P12 step table (fill only what you use for your preset)
			FXAA_QUALITY_P0: [number],
			FXAA_QUALITY_P1: [number],
			FXAA_QUALITY_P2: [number],
			FXAA_QUALITY_P3: [number],
			FXAA_QUALITY_P4: [number],
			FXAA_QUALITY_P5: [number],
			FXAA_QUALITY_P6: [number],
			FXAA_QUALITY_P7: [number],
			FXAA_QUALITY_P8: [number],
			FXAA_QUALITY_P9: [number],
			FXAA_QUALITY_P10: [number],
			FXAA_QUALITY_P11: [number],
			FXAA_QUALITY_P12: [number],

			pad: [number, number],
		}
		const settings = new DataBackedBuffer<FXAASettings>({
			FXAA_ENABLE: [1], // 	FXAA_ENABLE            : u32,
			FXAA_LUMA: [0],
			FXAA_GREEN_AS_LUMA: [1],

			// 	// core uniforms
			// RcpFrame: [1 / GPU.Renderer.width, 1 / GPU.Renderer.height], // 	RcpFrame                       : vec2f,  // 1/width, 1/height
			RcpFrameW: [1 / GPU.Renderer.width], // 	RcpFrame                       : vec2f,  // 1/width, 1/height
			RcpFrameH: [1 / GPU.Renderer.height],
			u_fxaaQualitySubpix: [0.75],
			u_fxaaQualityEdgeThreshold: [0.166],
			u_fxaaQualityEdgeThresholdMin: [0.0833],

			// 	// quality preset data
			FXAA_QUALITY_PS: [0],  // how many taps blocks are enabled (used like the old #if > N)

			// 	// the P0..P12 step table (fill only what you use for your preset)
			FXAA_QUALITY_P0: [0],
			FXAA_QUALITY_P1: [0],
			FXAA_QUALITY_P2: [0],
			FXAA_QUALITY_P3: [0],
			FXAA_QUALITY_P4: [0],
			FXAA_QUALITY_P5: [0],
			FXAA_QUALITY_P6: [0],
			FXAA_QUALITY_P7: [0],
			FXAA_QUALITY_P8: [0],
			FXAA_QUALITY_P9: [0],
			FXAA_QUALITY_P10: [0],
			FXAA_QUALITY_P11: [0],
			FXAA_QUALITY_P12: [0],

			pad: [0, 0] // pad
		}, GPU.BufferType.UNIFORM);

		const setPreset = (settings: DataBackedBuffer<any>, index: number) => {
			settings.set("FXAA_QUALITY_PS", [0]);
			settings.set("FXAA_QUALITY_P0", [0]);
			settings.set("FXAA_QUALITY_P1", [0]);
			settings.set("FXAA_QUALITY_P2", [0]);
			settings.set("FXAA_QUALITY_P3", [0]);
			settings.set("FXAA_QUALITY_P4", [0]);
			settings.set("FXAA_QUALITY_P5", [0]);
			settings.set("FXAA_QUALITY_P6", [0]);
			settings.set("FXAA_QUALITY_P7", [0]);
			settings.set("FXAA_QUALITY_P8", [0]);
			settings.set("FXAA_QUALITY_P9", [0]);
			settings.set("FXAA_QUALITY_P10", [0]);
			settings.set("FXAA_QUALITY_P11", [0]);
			settings.set("FXAA_QUALITY_P12", [0]);

			for (const key of Object.keys(presets[index])) {
				settings.set(key, [presets[index][key]]);
				console.log("Setting", key, [presets[index][key]])
			}
		}
		setPreset(settings, 16);
		const sampler = GPU.TextureSampler.Create({
			addressModeU: "clamp-to-edge",
			addressModeV: "clamp-to-edge",
			minFilter: "linear",
			magFilter: "linear",
			mipmapFilter: "nearest"
		});
		this.shader.SetSampler("u_sampler", sampler);
		this.shader.SetBuffer("fxaa", settings.buffer);

		this.renderTarget = GPU.RenderTexture.Create(GPU.Renderer.width, GPU.Renderer.height);

		this.initialized = true;

        const fxaaSettingsFolder = new UIFolder(Debugger.ui, "FXAA");
		console.log(settings.get("FXAA_ENABLE"))
		new UIDropdownStat(fxaaSettingsFolder, "PRESET:", ["10", "11", "12", "13", "14", "15", "20", "21", "22", "23", "24", "25", "25", "26", "27", "28", "29", "39"], (index, value) => setPreset(settings, index), 16);
		new UIButtonStat(fxaaSettingsFolder, "FXAA_ENABLE", state => settings.set("FXAA_ENABLE", [+state]), settings.get("FXAA_ENABLE")[0] > 0);
		new UIButtonStat(fxaaSettingsFolder, "FXAA_LUMA", state => settings.set("FXAA_LUMA", [+state]), settings.get("FXAA_LUMA")[0] > 0);
		new UIButtonStat(fxaaSettingsFolder, "FXAA_GREEN_AS_LUMA", state => settings.set("FXAA_GREEN_AS_LUMA", [+state]), settings.get("FXAA_GREEN_AS_LUMA")[0] > 0);
        new UISliderStat(fxaaSettingsFolder, "fxaaQualitySubpix:", 0, 1, 0.01, settings.get("u_fxaaQualitySubpix")[0], value => settings.set("u_fxaaQualitySubpix", [value]));
		new UISliderStat(fxaaSettingsFolder, "fxaaQualityEdgeThreshold:", 0, 1, 0.01, settings.get("u_fxaaQualityEdgeThreshold")[0], value => settings.set("u_fxaaQualityEdgeThreshold", [value]));
		new UISliderStat(fxaaSettingsFolder, "fxaaQualityEdgeThresholdMin:", 0, 1, 0.01, settings.get("u_fxaaQualityEdgeThresholdMin")[0], value => settings.set("u_fxaaQualityEdgeThresholdMin", [value]));

		fxaaSettingsFolder.Open();
	}

	public execute(resources: GPU.ResourcePool) {
		if (this.initialized === false) return;

		const LightingPassOutputTexture: GPU.Texture = resources.getResource(GPU.PassParams.LightingPassOutput);
		if (!LightingPassOutputTexture) return;

		this.shader.SetTexture("u_texture", LightingPassOutputTexture);

		GPU.RendererContext.BeginRenderPass(this.name, [{ clear: false, target: this.renderTarget }], undefined, true);
		GPU.RendererContext.DrawGeometry(this.quadGeometry, this.shader);
		GPU.RendererContext.EndRenderPass();

		GPU.Texture.Blit(this.renderTarget, LightingPassOutputTexture, this.renderTarget.width, this.renderTarget.height);
	}
}