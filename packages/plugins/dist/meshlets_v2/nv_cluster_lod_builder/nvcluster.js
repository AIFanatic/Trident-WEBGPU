import { clusterize } from "./clusterizer";
import { resizeArray, createArrayView } from "./nvclusterlod_common";
export class Range {
    offset = 0;
    count = 0;
    constructor(offset = 0, count = 0) {
        this.offset = offset;
        this.count = count;
    }
}
;
export class Config {
    // Minimum number of elements contained in a cluster
    minClusterSize = 1;
    // Maximum number of elements contained in a cluster
    maxClusterSize = ~0;
    // Cost penalty for under-filling clusters
    costUnderfill = 1.0;
    // Cost penalty for overlapping bounding boxes
    costOverlap = 0.01;
    // If nonzero the set of input elements will first be split along its median
    // until each subset contains at most preSplitThreshold elements prior to actual
    // clustering. This is an optimization intended to speed up clustering of large
    // sets of elements
    preSplitThreshold = 0;
}
;
export class AABB {
    bboxMin = [Infinity, Infinity, Infinity];
    bboxMax = [-Infinity, -Infinity, -Infinity];
    constructor(bboxMin = [Infinity, Infinity, Infinity], bboxMax = [-Infinity, -Infinity, -Infinity]) {
        this.bboxMin = bboxMin;
        this.bboxMax = bboxMax;
    }
}
;
// Spatial definition of elements to cluster
export class SpatialElements {
    // Bounding boxes of elements to cluster
    boundingBoxes;
    // Center positions (xyz) of elements to cluster
    centroids;
    // Number of elements
    elementCount = 0;
}
;
// Definition of the connectivity of the items to cluster
// While the data structure defines unidirectional connections the underlying
// clustering requires all connections to be explicitly bidirectional (if node A has a connection to node B, then node B has
// a connection to node A)
export class Graph {
    // Each node is defined by its connections to other nodes, stored at node.offset in connectionTargets. Each node has node.count connections
    nodes;
    // Total number of nodes in the graph
    nodeCount = 0;
    // Connection targets for the nodes, referenced by nodes
    connectionTargets;
    // Weight of each connection
    connectionWeights;
    // Total number of connections in the graph
    connectionCount = 0;
}
;
// Definition of the input data
export class Input {
    // Clustering configuration
    config = new Config();
    // Set of elements to cluster, required
    spatialElements = new SpatialElements();
    // Optional graph defining the weighted connectivity between elements, used to optimize a cost function
    // when clustering
    graph;
}
;
// Structure to request the memory requirements to individually cluster the provided segments of the input data
export class ClusterGetRequirementsSegmentedInfo {
    // Input elements to cluster
    input;
    // Each segment is defined by a range within the array of elements defined in input
    elementSegments;
    // Number of segments
    elementSegmentCount = 0;
}
;
// Structure to request the memory requirements to cluster the input data
export class ClusterGetRequirementsInfo {
    // Input elements to cluster
    input;
}
;
// Structure to request individual clustering of the provided segments of the input data
export class ClusterCreateSegmentedInfo {
    input;
    // Each segment is defined by a range within the array of elements defined in input
    elementSegments;
    // Number of segments
    elementSegmentCount = 0;
}
;
// Output of the clustering where the clusterRanges define a partition of the input elements
export class Output {
    // Clusters defined by ranges of element indices, where each cluster starts at range.offset in clusteredElementIndices and contains range.count elements
    clusterRanges;
    // Indices of the elements, referenced by clusterRanges
    clusteredElementIndices;
    // Total number of clusters generated by the clustering (may be less than maxClusterCount)
    clusterCount = 0;
    // Total number of cluster element indices (FIXME why, shouldn't this be the same as the input?)
    clusteredElementIndexCount = 0;
}
;
// Memory requirements for clustering
export class Requirements {
    // Maximum number of generated clusters
    maxClusterCount = 0;
    // Maximum total number of elements referenced by the clusters
    maxClusteredElementCount = 0;
}
;
// Structure to request clustering the input set of elements
export class ClusterCreateInfo {
    // Input elements to cluster
    input;
}
;
export var Result;
(function (Result) {
    Result[Result["SUCCESS"] = 0] = "SUCCESS";
    Result[Result["ERROR_INVALID_CREATE_INFO"] = 1] = "ERROR_INVALID_CREATE_INFO";
    Result[Result["ERROR_INTERNAL"] = 2] = "ERROR_INTERNAL";
    Result[Result["ERROR_INVALID_CONFIG"] = 3] = "ERROR_INVALID_CONFIG";
    Result[Result["ERROR_INVALID_BOUNDS"] = 4] = "ERROR_INVALID_BOUNDS";
    Result[Result["ERROR_INVALID_GRAPH"] = 5] = "ERROR_INVALID_GRAPH";
    Result[Result["ERROR_WEIGHT_OVERFLOW"] = 6] = "ERROR_WEIGHT_OVERFLOW";
    Result[Result["ERROR_INVALID_ARGUMENT"] = 7] = "ERROR_INVALID_ARGUMENT";
    Result[Result["ERROR_INVALID_CONTEXT"] = 8] = "ERROR_INVALID_CONTEXT";
})(Result || (Result = {}));
;
export function generateClusters(input, clusterStorage) {
    let info = new ClusterGetRequirementsInfo();
    info.input = input;
    let reqs = new Requirements();
    let result = nvclusterGetRequirements(info, reqs);
    if (result != Result.SUCCESS) {
        return result;
    }
    resizeArray(clusterStorage.clusterRanges, reqs.maxClusterCount, () => new Range());
    resizeArray(clusterStorage.clusterItems, reqs.maxClusteredElementCount, () => 0);
    let createInfo = new ClusterCreateInfo();
    createInfo.input = input;
    let clusters = new Output();
    clusters.clusteredElementIndices = clusterStorage.clusterItems;
    clusters.clusterRanges = clusterStorage.clusterRanges;
    clusters.clusterCount = reqs.maxClusterCount;
    clusters.clusteredElementIndexCount = reqs.maxClusteredElementCount;
    result = nvclusterCreate(createInfo, clusters);
    if (result == Result.SUCCESS) {
        resizeArray(clusterStorage.clusterRanges, clusters.clusterCount, () => new Range());
        resizeArray(clusterStorage.clusterItems, clusters.clusteredElementIndexCount, () => 0);
    }
    return result;
}
function nvclusterGetRequirements(info, requirements) {
    if (requirements == undefined) {
        return Result.ERROR_INVALID_ARGUMENT;
    }
    if (info.input.config.minClusterSize == 0 || info.input.config.maxClusterSize == 0) {
        // FIXME: return error code
        requirements = new Requirements();
        return Result.ERROR_INVALID_CONFIG;
    }
    const n = info.input.spatialElements.elementCount;
    const Ca = info.input.config.minClusterSize;
    const P = info.input.config.preSplitThreshold;
    const P_underfill = P == 0 ? 0 : (n + P - 1) / P;
    const maxClusters = (n + Ca - 1) / Ca + P_underfill;
    requirements.maxClusteredElementCount = Math.floor(n);
    requirements.maxClusterCount = Math.floor(maxClusters);
    return Result.SUCCESS;
}
export function nvclusterGetRequirementsSegmented(info, requirements) {
    if (requirements == undefined) {
        return Result.ERROR_INVALID_ARGUMENT;
    }
    requirements.maxClusterCount = 0;
    requirements.maxClusteredElementCount = 0;
    for (let itemSegmentIndex = 0; itemSegmentIndex < info.elementSegmentCount; itemSegmentIndex++) {
        const range = info.elementSegments[itemSegmentIndex];
        let segmentInfo = new ClusterGetRequirementsInfo();
        let segmentInput = new Input();
        let segmentBounds = new SpatialElements();
        segmentInput.config = info.input.config;
        segmentBounds.elementCount = range.count;
        segmentInput.spatialElements = segmentBounds;
        segmentInfo.input = segmentInput;
        let segmentResult = new Requirements();
        let res = nvclusterGetRequirements(segmentInfo, segmentResult);
        if (res != Result.SUCCESS) {
            return res;
        }
        requirements.maxClusterCount += segmentResult.maxClusterCount;
        requirements.maxClusteredElementCount += segmentResult.maxClusteredElementCount;
    }
    return Result.SUCCESS;
}
export function nvclusterCreate(info, clusters) {
    if (info == undefined || info.input == undefined || info.input.spatialElements == undefined) {
        return Result.ERROR_INVALID_CREATE_INFO;
    }
    let result = clusterize(info.input, clusters);
    return result;
}
export function nvclustersCreateSegmented(info, clusters, clusterSegments) {
    let sizes = new Requirements();
    for (let segmentIndex = 0; segmentIndex < info.elementSegmentCount; segmentIndex++) {
        const range = info.elementSegments[segmentIndex];
        let segmentInput = new Input();
        let segmentBounds = new SpatialElements();
        // segmentBounds.boundingBoxes  = info.input.spatialElements.boundingBoxes + range.offset;
        // segmentBounds.centroids      = info.input.spatialElements.centroids + 3 * range.offset;
        segmentBounds.boundingBoxes = info.input.spatialElements.boundingBoxes.slice(range.offset);
        segmentBounds.centroids = info.input.spatialElements.centroids.slice(3 * range.offset);
        segmentBounds.elementCount = range.count;
        segmentInput.spatialElements = segmentBounds;
        segmentInput.config = info.input.config;
        segmentInput.graph = info.input.graph;
        if (sizes.maxClusteredElementCount + range.count > clusters.clusteredElementIndexCount) {
            return Result.ERROR_INTERNAL;
        }
        let segmentedOutput = new Output();
        segmentedOutput.clusterRanges = createArrayView(clusters.clusterRanges, sizes.maxClusterCount, clusters.clusterCount - sizes.maxClusterCount);
        // segmentedOutput.clusterRanges = clusters.clusterRanges.slice(sizes.maxClusterCount);
        segmentedOutput.clusteredElementIndices = createArrayView(clusters.clusteredElementIndices, sizes.maxClusteredElementCount, clusters.clusteredElementIndexCount - sizes.maxClusteredElementCount);
        // segmentedOutput.clusteredElementIndices = clusters.clusteredElementIndices.slice(sizes.maxClusteredElementCount);
        segmentedOutput.clusterCount = clusters.clusterCount - sizes.maxClusterCount;
        segmentedOutput.clusteredElementIndexCount = range.count;
        if (segmentInput.spatialElements == undefined) {
            return Result.ERROR_INVALID_BOUNDS;
        }
        let result = clusterize(segmentInput, segmentedOutput);
        if (result != Result.SUCCESS) {
            return result;
        }
        if (sizes.maxClusterCount + segmentedOutput.clusterCount > clusters.clusterCount) {
            return Result.ERROR_INTERNAL;
        }
        // Translate local ranges offsets and item indices to global
        for (let rangeIndex = 0; rangeIndex < segmentedOutput.clusterCount; rangeIndex++) {
            const clusterRange = segmentedOutput.clusterRanges[rangeIndex];
            clusterRange.offset += sizes.maxClusteredElementCount;
        }
        for (let itemIndex = 0; itemIndex < segmentedOutput.clusteredElementIndexCount; itemIndex++) {
            segmentedOutput.clusteredElementIndices[itemIndex] += range.offset;
        }
        // Emit the segment of clustered items
        clusterSegments[segmentIndex] = new Range(sizes.maxClusterCount, segmentedOutput.clusterCount);
        sizes.maxClusterCount += segmentedOutput.clusterCount;
        sizes.maxClusteredElementCount += segmentedOutput.clusteredElementIndexCount;
        // console.log(`-----------------`);
        // console.log(`clusterSegments: [ Range { offset: ${clusterSegments[0].offset}, count: ${clusterSegments[0].count}}]`);
        // console.log(`clusters1111 Output2 {`);
        // console.log(`  clusterRanges: [ Range { offset: ${clusters.clusterRanges[0].offset}, count: ${clusters.clusterRanges[0].count}}, Range { offset: ${clusters.clusterRanges[1] ? clusters.clusterRanges[1].offset : 0}, count: ${clusters.clusterRanges[1] ? clusters.clusterRanges[1].count : 0}} ]`);
        // console.log(`  clusteredElementIndices: [ ${clusters.clusteredElementIndices[0]}, ${clusters.clusteredElementIndices[1]}, ${clusters.clusteredElementIndices[2]}, ${clusters.clusteredElementIndices[3]} ]`);
        // console.log(`  clusterCount: ${clusters.clusterCount}`);
        // console.log(`  clusteredElementIndexCount: ${clusters.clusteredElementIndexCount}`);
        // console.log(`}`);
        // console.log(`segmentedOutput1111 Output2 {`);
        // console.log(`  clusterRanges: [ Range { offset: ${segmentedOutput.clusterRanges[0].offset}, count: ${segmentedOutput.clusterRanges[0].count}}, Range { offset: ${segmentedOutput.clusterRanges[1] ? segmentedOutput.clusterRanges[1].offset : 0}, count: ${segmentedOutput.clusterRanges[1] ? segmentedOutput.clusterRanges[1].count : 0}} ]`);
        // console.log(`  clusteredElementIndices: [ ${segmentedOutput.clusteredElementIndices[0]}, ${segmentedOutput.clusteredElementIndices[1]}, ${segmentedOutput.clusteredElementIndices[2]}, ${segmentedOutput.clusteredElementIndices[3]} ]`);
        // console.log(`  clusterCount: ${segmentedOutput.clusterCount}`);
        // console.log(`  clusteredElementIndexCount: ${segmentedOutput.clusteredElementIndexCount}`);
        // console.log(`}`);
        // console.log(`-----------------`);
    }
    /*********************************************/
    clusters.clusteredElementIndexCount = sizes.maxClusteredElementCount;
    clusters.clusterCount = sizes.maxClusterCount;
    return Result.SUCCESS;
}
