import {
    Components,
    Scene,
    GPU,
    Mathf,
    GameObject,
    Geometry,
    VertexAttribute,
    IndexAttribute,
    Utils,
} from "@trident/core";

import { OrbitControls } from "@trident/plugins/OrbitControls";
import { Debugger } from "@trident/plugins/Debugger";

// VoxelWorld Surface-Positions Generator
// - Good visuals: layered fBm heightfield + ridged noise caves
// - Flexible world size: chunked generation (configurable chunk size & grid)
// - Output: Float32Array of world-space positions (x,y,z) for *surface* voxels
//   (ideal for GPU instancing of cubes with a per-instance vec3)

// ---------- Config Types ----------
export type VoxelWorldConfig = {
    // Chunking
    chunkSize: number;           // voxels per edge in a chunk (e.g., 32 or 48)
    chunkCount: [number, number, number]; // number of chunks in x,y,z (e.g., [8,2,8])
    voxelScale: number;          // world units per voxel (cube size)
  
    // Terrain
    seed: number;                // seed for deterministic worlds
    baseHeight: number;          // average terrain height in voxels
    heightAmp: number;           // amplitude of height variations in voxels
    heightFrequency: number;     // frequency for heightfield (smaller => broader hills)
    heightOctaves: number;       // octaves for fBm heightfield
    heightLacunarity: number;
    heightGain: number;
  
    // Caves (ridged noise subtracts density)
    caveEnabled: boolean;
    caveFrequency: number;
    caveOctaves: number;
    caveLacunarity: number;
    caveGain: number;
    caveStrength: number;        // how aggressively caves carve (0..1+)
    caveThreshold: number;       // threshold to create hollow regions
  
    // Utilities
    surfaceOnly: boolean;        // if true, only emit voxels exposed to air (recommended)
  };
  
  // ---------- Fast RNG / Hash Utilities ----------
  function xorshift32(seed: number) {
    let x = seed | 0;
    return function() {
      // Xorshift32
      x ^= x << 13; x |= 0;
      x ^= x >>> 17; x |= 0;
      x ^= x << 5;  x |= 0;
      // map to [0,1)
      return ((x >>> 0) / 0x100000000);
    };
  }
  
  function mulberry32(seed: number) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  
  // Lattice hash → [0,1)
  function hash3ToUnit(rngSeed: number, xi: number, yi: number, zi: number): number {
    // mix coordinates with seed (use 32-bit wrapping multiplies)
    let h = Math.imul(xi * 374761393, 1) ^ Math.imul(yi * 668265263, 1) ^ Math.imul(zi * 2147483647, 1) ^ rngSeed;
    h ^= h >>> 13; h = Math.imul(h, 1274126177);
    h ^= h >>> 16;
    return (h >>> 0) / 4294967296;
  }
  
  function smoothStep(t: number) { return t * t * (3 - 2 * t); }
  
  // Trilinear value noise in [0,1)
  function valueNoise3(seed: number, x: number, y: number, z: number): number {
    const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    const xf = x - xi,      yf = y - yi,      zf = z - zi;
    const u = smoothStep(xf), v = smoothStep(yf), w = smoothStep(zf);
  
    const c000 = hash3ToUnit(seed, xi,   yi,   zi);
    const c100 = hash3ToUnit(seed, xi+1, yi,   zi);
    const c010 = hash3ToUnit(seed, xi,   yi+1, zi);
    const c110 = hash3ToUnit(seed, xi+1, yi+1, zi);
    const c001 = hash3ToUnit(seed, xi,   yi,   zi+1);
    const c101 = hash3ToUnit(seed, xi+1, yi,   zi+1);
    const c011 = hash3ToUnit(seed, xi,   yi+1, zi+1);
    const c111 = hash3ToUnit(seed, xi+1, yi+1, zi+1);
  
    const x00 = c000 * (1 - u) + c100 * u;
    const x10 = c010 * (1 - u) + c110 * u;
    const x01 = c001 * (1 - u) + c101 * u;
    const x11 = c011 * (1 - u) + c111 * u;
  
    const y0 = x00 * (1 - v) + x10 * v;
    const y1 = x01 * (1 - v) + x11 * v;
  
    return y0 * (1 - w) + y1 * w; // [0,1)
  }
  
  // fBm in [-1,1]
  function fbm3(seed: number, p: [number, number, number], octaves: number, lacunarity: number, gain: number, freq: number): number {
    let amp = 0.5;
    let sum = 0;
    let totalAmp = 0;
    let fx = p[0] * freq, fy = p[1] * freq, fz = p[2] * freq;
    for (let i = 0; i < octaves; i++) {
      const n = valueNoise3(seed + i * 101, fx, fy, fz) * 2 - 1; // [-1,1]
      sum += n * amp;
      totalAmp += amp;
      amp *= gain;
      fx *= lacunarity; fy *= lacunarity; fz *= lacunarity;
    }
    return sum / totalAmp;
  }
  
  // Ridged fBm (absolute value, inverted), ~[0,1]
  function ridged3(seed: number, p: [number, number, number], octaves: number, lacunarity: number, gain: number, freq: number): number {
    let amp = 0.5;
    let sum = 0;
    let fx = p[0] * freq, fy = p[1] * freq, fz = p[2] * freq;
    for (let i = 0; i < octaves; i++) {
      const n = 1 - Math.abs(valueNoise3(seed + i * 131, fx, fy, fz) * 2 - 1); // [0,1], ridged
      sum += n * amp;
      amp *= gain;
      fx *= lacunarity; fy *= lacunarity; fz *= lacunarity;
    }
    return sum; // ~[0,1]
  }
  
  // ---------- Density Function ----------
  // Positive density → solid voxel; <= 0 → empty.
  function densityAt(cfg: VoxelWorldConfig, x: number, y: number, z: number): number {
    // Heightfield (depend on x,z only)
    const hBase = cfg.baseHeight;
    const hVar = cfg.heightAmp * fbm3(cfg.seed ^ 0xA53, [x, 0, z], cfg.heightOctaves, cfg.heightLacunarity, cfg.heightGain, cfg.heightFrequency);
    const height = hBase + hVar; // target surface height in voxels
  
    // Terrain density: positive below height, negative above
    let d = height - y;
  
    if (cfg.caveEnabled) {
      // Carve caves using ridged noise in 3D
      const cave = ridged3(cfg.seed ^ 0xC4FE, [x, y, z], cfg.caveOctaves, cfg.caveLacunarity, cfg.caveGain, cfg.caveFrequency);
      // Make a hollow band around threshold; subtract strength around threshold to form tunnels
      const carve = (cave - cfg.caveThreshold) * cfg.caveStrength;
      d -= carve;
    }
  
    return d;
  }
  
  // ---------- Chunk Generation ----------
  export type ChunkKey = `${number},${number},${number}`;
  
  export type ChunkPositions = {
    key: ChunkKey;           // "cx,cy,cz"
    positions: Float32Array; // length = count * 3 (x,y,z)
    count: number;           // number of voxels emitted
  };
  
  function makeKey(cx: number, cy: number, cz: number): ChunkKey { return `${cx},${cy},${cz}` as ChunkKey; }
  
  export function generateChunkSurfacePositions(cfg: VoxelWorldConfig, cx: number, cy: number, cz: number): ChunkPositions {
    const N = cfg.chunkSize;
    const scale = cfg.voxelScale;
  
    const worldX0 = cx * N;
    const worldY0 = cy * N;
    const worldZ0 = cz * N;
  
    const posArray: number[] = [];
  
    // Precompute a small cache of densities for neighbor tests (pad by 1)
    const S = N + 2; // padded edge
    const dens = new Float32Array(S * S * S);
    const idx = (i: number, j: number, k: number) => (i * S + j) * S + k;
  
    for (let i = 0; i < S; i++) {
      for (let j = 0; j < S; j++) {
        for (let k = 0; k < S; k++) {
          const x = worldX0 + (i - 1);
          const y = worldY0 + (j - 1);
          const z = worldZ0 + (k - 1);
          dens[idx(i,j,k)] = densityAt(cfg, x, y, z);
        }
      }
    }
  
    // Iterate inner N^3 cells; emit only exposed (surface) voxels if requested
    for (let i = 1; i <= N; i++) {
      for (let j = 1; j <= N; j++) {
        for (let k = 1; k <= N; k++) {
          const d = dens[idx(i,j,k)];
          if (d <= 0) continue; // empty
  
          const exposed = (
            dens[idx(i-1,j,  k  )] <= 0 ||
            dens[idx(i+1,j,  k  )] <= 0 ||
            dens[idx(i,  j-1,k  )] <= 0 ||
            dens[idx(i,  j+1,k  )] <= 0 ||
            dens[idx(i,  j,  k-1)] <= 0 ||
            dens[idx(i,  j,  k+1)] <= 0
          );
  
          if (!cfg.surfaceOnly || exposed) {
            const wx = (worldX0 + (i - 1)) * scale;
            const wy = (worldY0 + (j - 1)) * scale;
            const wz = (worldZ0 + (k - 1)) * scale;
            posArray.push(wx, wy, wz);
          }
        }
      }
    }
  
    const positions = new Float32Array(posArray);
    return { key: makeKey(cx, cy, cz), positions, count: positions.length / 3 };
  }
  
  // Generate entire world (returns per-chunk results). For very large worlds, prefer streaming/generators.
  export function generateWorldPositions(cfg: VoxelWorldConfig): ChunkPositions[] {
    const [CX, CY, CZ] = cfg.chunkCount;
    const out: ChunkPositions[] = [];
    for (let cx = 0; cx < CX; cx++) {
      for (let cy = 0; cy < CY; cy++) {
        for (let cz = 0; cz < CZ; cz++) {
          out.push(generateChunkSurfacePositions(cfg, cx, cy, cz));
        }
      }
    }
    return out;
  }
  
  // A streaming generator version to avoid big allocations
  export function *streamWorldPositions(cfg: VoxelWorldConfig): Generator<ChunkPositions> {
    const [CX, CY, CZ] = cfg.chunkCount;
    for (let cx = 0; cx < CX; cx++)
      for (let cy = 0; cy < CY; cy++)
        for (let cz = 0; cz < CZ; cz++)
          yield generateChunkSurfacePositions(cfg, cx, cy, cz);
  }
  
  // ---------- Example Usage ----------
  // (1) Create a config
  export const defaultVoxelConfig: VoxelWorldConfig = {
    chunkSize: 32,
    chunkCount: [8, 2, 8],     // 8x2x8 chunks
    voxelScale: 1.0,
  
    seed: 1337,
    baseHeight: 20,
    heightAmp: 14,
    heightFrequency: 0.008,
    heightOctaves: 5,
    heightLacunarity: 2.0,
    heightGain: 0.5,
  
    caveEnabled: true,
    caveFrequency: 0.03,
    caveOctaves: 4,
    caveLacunarity: 2.1,
    caveGain: 0.5,
    caveStrength: 1.2,
    caveThreshold: 0.55,
  
    surfaceOnly: true,
  };
  
  // (2) Generate chunks and feed to your GPU instancer (vec3 per instance)
  // const world = generateWorldPositions(defaultVoxelConfig);
  // for (const chunk of world) {
  //   // chunk.positions is Float32Array [x0,y0,z0, x1,y1,z1, ...]
  //   // Example with your system: one Object mesh (cube) + set per-instance data
  //   // You can either concatenate into one giant positions buffer or render per-chunk.
  // }
  
  // Tips for integration with your Trident setup:
  // - Use a dedicated VERTEX buffer for instance data with stepMode = "instance" (preferred), or keep your STORAGE buffer approach but ensure a vec3 stride.
  // - Keep per-instance stride consistent (3 floats). Avoid writing 4 floats if you allocated 3.
  // - For huge worlds, call streamWorldPositions and upload chunk-by-chunk.
  // - To vary visuals further, you can add a biome mask using another fbm over (x,z) to modulate baseHeight/heightAmp.
  

class DynamicBufferMemoryAllocator {
    protected allocator: GPU.MemoryAllocator;
    protected buffer: GPU.Buffer;
    protected links: Map<any, number>;
    private incrementAmount: number;

    protected static BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
    protected bufferType: GPU.BufferType;

    constructor(size: number, bufferType = GPU.BufferType.STORAGE, incrementAmount?: number) {
        this.allocator = new GPU.MemoryAllocator(size);
        this.buffer = GPU.Buffer.Create(size * DynamicBufferMemoryAllocator.BYTES_PER_ELEMENT, bufferType);
        this.links = new Map();
        this.bufferType = bufferType;
        this.incrementAmount = incrementAmount ? incrementAmount : size;
    }

    public set(link: any, data: Float32Array | Uint32Array, offset: number = 0): { byteOffset: number, byteSize: number, elemOffset: number } {
        let bufferOffset = this.links.get(link);
        if (bufferOffset === undefined) {
            if (this.allocator.availableMemorySize - data.length < 0) {
                // Increment allocator
                const o = this.allocator.memorySize;
                const incrementAmount = this.incrementAmount > data.length ? this.incrementAmount : data.length;
                const oldMemorySize = this.allocator.memorySize - this.allocator.availableMemorySize;
                this.allocator.memorySize += incrementAmount;
                this.allocator.availableMemorySize += incrementAmount;
                this.allocator.freeBlocks.push({ offset: oldMemorySize, size: incrementAmount });
                console.log(`Incrementing DynamicBuffer from ${o} to ${this.allocator.memorySize}`)

                // Create new buffer
                const buffer = GPU.Buffer.Create(this.allocator.memorySize * DynamicBufferMemoryAllocator.BYTES_PER_ELEMENT, this.bufferType);
                const hasActiveFrame = GPU.Renderer.HasActiveFrame();
                if (!hasActiveFrame) GPU.Renderer.BeginRenderFrame();
                GPU.RendererContext.CopyBufferToBuffer(this.buffer, buffer);
                if (!hasActiveFrame) GPU.Renderer.EndRenderFrame();

                const oldBuffer = this.buffer;
                GPU.Renderer.OnFrameCompleted().then(() => {
                    oldBuffer.Destroy();
                })

                this.buffer = buffer;
            }

            bufferOffset = this.allocator.allocate(data.length);
            this.links.set(link, bufferOffset);
        }
        const byteOffset = bufferOffset * DynamicBufferMemoryAllocator.BYTES_PER_ELEMENT;
        this.buffer.SetArray(data, byteOffset + offset, 0, data.length);
        return { byteOffset: byteOffset, byteSize: data.byteLength, elemOffset: bufferOffset };
        // return bufferOffset;
    }

    public delete(link: any) {
        const bufferOffset = this.links.get(link);
        if (bufferOffset === undefined) throw Error("Link not found");
        this.allocator.free(bufferOffset);
        this.links.delete(link);
        // TODO: Resize buffer
    }

    public getBuffer(): GPU.Buffer { return this.buffer; }
    public getAllocator(): GPU.MemoryAllocator { return this.allocator; }
}


async function Application(canvas: HTMLCanvasElement) {
    const renderer = GPU.Renderer.Create(canvas, "webgpu");
    const scene = new Scene(renderer);

    const mainCameraGameObject = new GameObject(scene);
    mainCameraGameObject.transform.position.set(0, 0, -15);
    mainCameraGameObject.name = "MainCamera";
    const camera = mainCameraGameObject.AddComponent(Components.Camera);
    camera.SetPerspective(72, canvas.width / canvas.height, 0.5, 1000);


    mainCameraGameObject.transform.position.set(0, 0, 2);
    mainCameraGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));

    const controls = new OrbitControls(canvas, camera);

    const lightGameObject = new GameObject(scene);
    lightGameObject.transform.position.set(-4, 4, 4);
    lightGameObject.transform.LookAtV1(new Mathf.Vector3(0, 0, 0));
    const light = lightGameObject.AddComponent(Components.DirectionalLight);
    light.intensity = 1000;


    const cubeGeometry = Geometry.Cube();
    const cubeVertices = cubeGeometry.attributes.get("position").array as Float32Array;
    const cubeNormals = cubeGeometry.attributes.get("normal").array as Float32Array;
    const cubeIndices = cubeGeometry.index.array as Uint32Array;
    const sphereGeometry = Geometry.Sphere();
    const sphereVertices = sphereGeometry.attributes.get("position").array as Float32Array;
    const sphereNormals = sphereGeometry.attributes.get("normal").array as Float32Array;
    const sphereIndices = sphereGeometry.index.array as Uint32Array;

    const size = 1000000;
    const vertexBuffer = new DynamicBufferMemoryAllocator(size, GPU.BufferType.VERTEX);
    const normalsBuffer = new DynamicBufferMemoryAllocator(size, GPU.BufferType.VERTEX);
    const indexBuffer = new DynamicBufferMemoryAllocator(size, GPU.BufferType.INDEX);

    const dataBuffer = new DynamicBufferMemoryAllocator(size, GPU.BufferType.STORAGE);
    const pointersBuffer = new DynamicBufferMemoryAllocator(size, GPU.BufferType.STORAGE);
    // const pointersBuffer = GPU.Buffer.Create(size, GPU.BufferType.STORAGE);

    interface BufferAllocation {
        byteOffset: number;
        byteSize: number;
        elemOffset: number;
    };

    let objectCount = 0;
    class Object {
        public readonly id = Utils.UUID();

        public readonly vertexBufferAllocator: BufferAllocation;
        public readonly normalBufferAllocator: BufferAllocation;
        public readonly indexBufferAllocator: BufferAllocation;
        public readonly dataAllocator: BufferAllocation;
        public readonly pointerAllocator: BufferAllocation;
        public readonly instanceCount: number;
        public readonly dataSize: number;

        constructor(vertices: Float32Array, normals: Float32Array, indices: Uint32Array, dataSize: number, instanceCount: number = 1) {
            const verticesCRC = Utils.CRC32.forBytes(new Uint8Array(vertices.buffer));
            const normalsCRC = Utils.CRC32.forBytes(new Uint8Array(normals.buffer));
            const indicesCRC = Utils.CRC32.forBytes(new Uint8Array(indices.buffer));

            this.vertexBufferAllocator = vertexBuffer.set(verticesCRC, vertices);
            this.normalBufferAllocator = normalsBuffer.set(normalsCRC, normals);
            this.indexBufferAllocator = indexBuffer.set(indicesCRC, indices);
            this.dataAllocator = dataBuffer.set(this.id, new Float32Array(dataSize * instanceCount));
            this.instanceCount = instanceCount;
            this.dataSize = dataSize;

            for (let i = 0; i < instanceCount; i++) {
                this.pointerAllocator = pointersBuffer.set(`${this.id}-${i}`, new Uint32Array([objectCount * dataSize]));
                objectCount++;
            }
        }

        public setData(data: Float32Array, offset: number = 0) {
            dataBuffer.set(this.id, data, offset * 4);
        }

        public setInstanceData(data: Float32Array, instanceIndex: number) {
            this.setData(data, this.dataSize * instanceIndex);
        }
    }

    let objects: Object[] = [];

    const c = 10000;
    // for (let i = 0; i < c; i++) {
    //     const off = 100;
    //     const r = (off) => (Math.random() * off) - off * 0.5;
    //     const object = new Object(cubeVertices, cubeIndices, 3, 1);
    //     object.setData(new Float32Array([r(off), r(off), r(off)]));
    //     objects.push(object);
    // }

    // Instances
    const cubes = new Object(cubeVertices, cubeNormals, cubeIndices, 3, c);
    const spheres = new Object(sphereVertices, sphereNormals, sphereIndices, 3, c);
    objects.push(cubes);
    // objects.push(spheres);
    for (let i = 0; i < c; i++) {
        const off = 100;
        const r = (off) => (Math.random() * off) - off * 0.5;
        cubes.setInstanceData(new Float32Array([r(off), r(off), r(off), 1.0]), i);
        // spheres.setInstanceData(new Float32Array([r(off), r(off), r(off), 1.0]), i);
    }

    // const worldGen = streamWorldPositions(defaultVoxelConfig);
    // let positions: number[] = [];
    // for (const chunk of worldGen) {
    //     // chunk.positions is Float32Array of [x,y,z, ...]
    //     positions.push(...chunk.positions);
    // }
    // const cubes = new Object(cubeVertices, cubeIndices, 3, positions.length / 3);

    // // Upload each voxel position
    // for (let i = 0; i < positions.length / 3; i++) {
    //     const x = positions[i*3+0];
    //     const y = positions[i*3+1];
    //     const z = positions[i*3+2];
    //     cubes.setInstanceData(new Float32Array([x, y, z]), i);
    // }
    // objects.push(cubes);


    console.log(objects.length)

    // const object0 = new Object(cubeVertices, cubeIndices, 3, 2);
    // object0.setData(new Float32Array([-1, 0, 0]), 0);
    // object0.setData(new Float32Array([1, 0, 0]), 3);
    // object0.setInstanceData(new Float32Array([-1, 0, 0]), 0);
    // object0.setInstanceData(new Float32Array([1, 0, 0]), 1);
    // objects.push(object0);

    // const object1 = new Object(cubeVertices, cubeIndices, 3, 1);
    // object1.setData(new Float32Array([1, 0, 0]));
    // objects.push(object1);


    console.log(objects);

    console.log("pointersBuffer", pointersBuffer)
    console.log("dataBuffer", dataBuffer)

    // TODO: Dodgy
    const globalVerticesAttribute = new VertexAttribute(new Float32Array([0]));
    const globalNormalsAttribute = new VertexAttribute(new Float32Array([0]));
    const globalIndicesAttribute = new IndexAttribute(new Uint32Array([0]));
    globalVerticesAttribute.buffer = vertexBuffer.getBuffer();
    globalVerticesAttribute.buffer = normalsBuffer.getBuffer();
    globalIndicesAttribute.buffer = indexBuffer.getBuffer();

    const globalGeometry = new Geometry();
    globalGeometry.attributes.set("position", globalVerticesAttribute);
    globalGeometry.attributes.set("normal", globalNormalsAttribute);
    globalGeometry.index = globalIndicesAttribute;

    class TestPass extends GPU.RenderPass {
        private shader: GPU.Shader;

        public name: string = "TestPass";

        constructor() {
            super({});
        }

        public async init(resources: GPU.ResourcePool) {

            this.shader = await GPU.Shader.Create({
                code: `
                struct VertexInput {
                    @builtin(instance_index) instanceIdx : u32, 
                    @location(0) position : vec3<f32>,
                    @location(1) normal : vec3<f32>,
                };
                
                struct VertexOutput {
                    @builtin(position) position : vec4<f32>,
                    @location(0) color : vec3<f32>,
                    @location(1) normal : vec3<f32>
                };

                struct InstanceData {
                    position: vec4<f32>,
                };
                @group(0) @binding(0) var<storage, read> data: array<u32>;
                // @group(0) @binding(0) var<storage, read> data: array<InstanceData>;
                @group(0) @binding(1) var<storage, read> pointers : array<u32>;

                @group(1) @binding(0) var<storage, read> projectionMatrix: mat4x4<f32>;
                @group(1) @binding(1) var<storage, read> viewMatrix: mat4x4<f32>;
                
                @vertex
                fn vertexMain(input: VertexInput) -> VertexOutput {
                    var output : VertexOutput;

                    // let baseAddress = pointers[input.instanceIdx];
                    let baseAddress = pointers[input.instanceIdx];
                
                    let position = vec3f(bitcast<f32>(data[baseAddress + 0]), bitcast<f32>(data[baseAddress + 1]), bitcast<f32>(data[baseAddress + 2]));
                    // let color = vec3f(bitcast<f32>(data[baseAddress + 3]), bitcast<f32>(data[baseAddress + 4]), bitcast<f32>(data[baseAddress + 5]));

                    // let instanceData = data[baseAddress];
                    
                    output.position = projectionMatrix * viewMatrix * vec4(input.position + position.xyz, 1.0);
                    output.normal = input.normal;

                    return output;
                }
                
                struct FragmentOutput {
                    @location(0) albedo: vec4<f32>,
                    @location(1) normal: vec4<f32>,
                    @location(2) ermo: vec4<f32>,
                };

                @fragment
                fn fragmentMain(input: VertexOutput) -> FragmentOutput {
                    var output: FragmentOutput;
                    // return vec4f(input.color + 0.5, 1.0);
                    output.albedo = vec4f(input.color + 0.5, 1.0);
                    output.normal = vec4f(input.color + 0.5, 1.0);

                    return output;
                }
                `,
                colorOutputs: [
                    { format: "rgba16float" },
                    { format: "rgba16float" },
                    { format: "rgba16float" },
                ],
                depthOutput: "depth24plus",
                attributes: {
                    position: { location: 0, size: 3, type: "vec3" },
                    normal: { location: 1, size: 3, type: "vec3" },
                },
                uniforms: {
                    data: { group: 0, binding: 0, type: "storage" },
                    pointers: { group: 0, binding: 1, type: "storage" },
                    projectionMatrix: { group: 1, binding: 0, type: "storage" },
                    viewMatrix: { group: 1, binding: 1, type: "storage" },
                }
            })

            this.shader.SetBuffer("data", dataBuffer.getBuffer());
            this.shader.SetBuffer("pointers", pointersBuffer.getBuffer());
            this.initialized = true;
        }

        public execute(resources: GPU.ResourcePool) {
            if (!this.initialized) return;

            const camera = Components.Camera.mainCamera;

            this.shader.SetMatrix4("projectionMatrix", camera.projectionMatrix);
            this.shader.SetMatrix4("viewMatrix", camera.viewMatrix);

            // this.shader.Compile();

            // if (!this.shader.pipeline) throw Error("Shader doesnt have a pipeline");

            // const LightingPassOutput = resources.getResource(GPU.PassParams.LightingPassOutput);
            // GPU.RendererContext.BeginRenderPass(this.name, [{ target: LightingPassOutput, clear: true }], undefined, true);
            const GBufferAlbedo = resources.getResource(GPU.PassParams.GBufferAlbedo);
            const GBufferNormal = resources.getResource(GPU.PassParams.GBufferNormal);
            const GBufferERMO = resources.getResource(GPU.PassParams.GBufferERMO);
            const GBufferDepth = resources.getResource(GPU.PassParams.GBufferDepth);
            GPU.RendererContext.BeginRenderPass(this.name, [
                { target: GBufferAlbedo, clear: true },
                { target: GBufferNormal, clear: true },
                { target: GBufferERMO, clear: true }
            ], {target: GBufferDepth, clear: true}, true);

            let i = 0;
            for (const object of objects) {
                globalVerticesAttribute.currentOffset = object.vertexBufferAllocator.byteOffset;
                globalVerticesAttribute.currentSize = object.vertexBufferAllocator.byteSize;
                globalNormalsAttribute.currentOffset = object.normalBufferAllocator.byteOffset;
                globalNormalsAttribute.currentSize = object.normalBufferAllocator.byteSize;
                globalIndicesAttribute.currentOffset = object.indexBufferAllocator.byteOffset;
                globalIndicesAttribute.currentSize = object.indexBufferAllocator.byteSize;

                GPU.RendererContext.DrawIndexed(globalGeometry, this.shader, object.indexBufferAllocator.byteSize / 4, object.instanceCount, 0, 0, i);
                i += object.instanceCount;
            }
            GPU.RendererContext.EndRenderPass();
        }
    }

    const testPass = new TestPass();
    scene.renderPipeline.AddPass(testPass, GPU.RenderPassOrder.AfterGBuffer);
    Debugger.Enable();

    scene.Start();

};

Application(document.querySelector("canvas"));